{
  "name": "Master Orchestrator - Campaign Pipeline v1.1",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "campaign-pipeline",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook - Campaign Pipeline",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [0, 0],
      "webhookId": "campaign-pipeline"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"received\": true, \"campaignId\": $json.body.campaignId } }}",
        "options": {
          "responseCode": 200
        }
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [220, 0]
    },
    {
      "parameters": {
        "jsCode": "// HMAC-SHA256 Verification\n// Verify X-Signature header against body using N8N_WEBHOOK_SECRET\n\nconst crypto = require('crypto');\n\nconst signature = $input.first().json.headers['x-signature'];\nconst body = JSON.stringify($input.first().json.body);\nconst secret = $env.N8N_WEBHOOK_SECRET;\n\nif (!secret) {\n  throw new Error('N8N_WEBHOOK_SECRET environment variable is not set');\n}\n\nif (!signature) {\n  throw new Error('Missing X-Signature header');\n}\n\nconst expectedSignature = crypto\n  .createHmac('sha256', secret)\n  .update(body)\n  .digest('hex');\n\nconst isValid = crypto.timingSafeEqual(\n  Buffer.from(signature, 'hex'),\n  Buffer.from(expectedSignature, 'hex')\n);\n\nif (!isValid) {\n  throw new Error('Invalid HMAC signature');\n}\n\n// Pass through the verified body\nreturn [{ json: $input.first().json.body }];"
      },
      "id": "hmac-verify",
      "name": "HMAC Verification",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [440, 0]
    },
    {
      "parameters": {
        "jsCode": "// Initialize PipelineState\n// Extract fields from webhook body and build initial pipeline state\n\nconst input = $input.first().json;\n\nconst pipelineState = {\n  version: 'v1.1',\n  campaignId: input.campaignId,\n  mode: input.mode || 'pro',\n  status: 'running',\n  agentErrors: [],\n  startedAt: new Date().toISOString()\n};\n\nreturn [{\n  json: {\n    campaignId: input.campaignId,\n    brief: input.brief,\n    brandProfile: input.brandProfile,\n    agentConfig: input.agentConfig,\n    mode: input.mode || 'pro',\n    brandMemory: input.brandMemory || null,\n    pipelineVersion: input.pipelineVersion || 'v1.1',\n    pipelineState\n  }\n}];"
      },
      "id": "init-pipeline",
      "name": "Initialize PipelineState",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [660, 0]
    },
    {
      "parameters": {
        "jsCode": "// Progress Callback Helper\n// Sends progress updates back to Next.js via HMAC-signed POST\n//\n// Usage: Set $json.callbackPayload before this node with the payload to send.\n// The node will sign it and POST to NEXTJS_CALLBACK_URL.\n\nconst crypto = require('crypto');\n\nconst callbackUrl = $env.NEXTJS_CALLBACK_URL;\nconst secret = $env.N8N_WEBHOOK_SECRET;\n\nif (!callbackUrl) {\n  throw new Error('NEXTJS_CALLBACK_URL environment variable is not set');\n}\n\nconst payload = $input.first().json.callbackPayload;\nif (!payload) {\n  // No callback payload set, pass through\n  return [$input.first()];\n}\n\nconst body = JSON.stringify(payload);\nconst signature = crypto\n  .createHmac('sha256', secret)\n  .update(body)\n  .digest('hex');\n\nconst response = await fetch(callbackUrl, {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n    'X-Signature': signature\n  },\n  body\n});\n\nif (!response.ok) {\n  console.warn(`Callback failed: HTTP ${response.status}`);\n}\n\n// Pass through pipeline data (excluding callbackPayload)\nconst { callbackPayload: _, ...rest } = $input.first().json;\nreturn [{ json: rest }];"
      },
      "id": "callback-helper",
      "name": "Progress Callback Helper",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [880, 0],
      "disabled": true
    },
    {
      "parameters": {
        "source": "database",
        "workflowId": "916Lre4ppJHXM9fO",
        "options": {}
      },
      "id": "agent-strategic-insight",
      "name": "Strategic Insight Agent",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [1100, 0],
      "continueOnFail": false,
      "notes": "Execute Sub-workflow: strategic-insight-agent.json. Sub-workflow handles: build-prompt fetch, Anthropic API call, response parsing, quality gate (ORCH-09), progress callbacks, cost tracking. Returns PipelineState with strategicInsight populated. Critical-stop: pipeline halts if this fails."
    },
    {
      "parameters": {
        "source": "database",
        "workflowId": "v65ieTAXTVP7SSPa",
        "options": {}
      },
      "id": "agent-creative-director",
      "name": "Creative Director Agent",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [1540, 0],
      "continueOnFail": false,
      "notes": "Execute Sub-workflow: creative-director-agent.json. Sub-workflow handles: build-prompt fetch (mode-dependent schema), Anthropic API call, response parsing (auto: flat, pro: 2-3 concepts), progress callbacks, cost tracking. Returns PipelineState with creativeDirector populated. Critical-stop: pipeline halts if this fails."
    },
    {
      "parameters": {
        "source": "database",
        "workflowId": "kPZPVtwVKdAM33H1",
        "options": {}
      },
      "id": "agent-copywriter",
      "name": "Copywriter Agent",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [1760, -120],
      "onError": "continueRegularOutput",
      "notes": "Execute Sub-workflow: copywriter-agent.json. Runs in PARALLEL with Art Director. Sub-workflow handles: build-prompt fetch (register maps, platform norms, copywriting frameworks), Anthropic API call (180s timeout), response parsing (4 variants per platform), progress callbacks, cost tracking. Partial-delivery: pipeline continues if this fails."
    },
    {
      "parameters": {
        "source": "database",
        "workflowId": "2XFM7OFX8xailoKS",
        "options": {}
      },
      "id": "agent-art-director",
      "name": "Art Director Agent",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [1760, 120],
      "onError": "continueRegularOutput",
      "notes": "Execute Sub-workflow: art-director-agent.json. Runs in PARALLEL with Copywriter. Sub-workflow handles: build-prompt fetch (GENX-09 default inference, camera/lens database, Flux constraints, mode-dependent schema), Anthropic API call (180s timeout), response parsing (no negativePrompt). Partial-delivery: pipeline continues if this fails."
    },
    {
      "parameters": {
        "jsCode": "// Merge Copywriter and Art Director parallel branches\n// Combines outputs from both branches into a single PipelineState.\n// Branch 1 (Copywriter) contributes pipelineState.copywriter\n// Branch 2 (Art Director) contributes pipelineState.artDirector\n// Both may also contribute agentErrors for partial-delivery.\n\nconst items = $input.all();\n\nif (items.length < 2) {\n  // Only one branch completed (edge case: one branch errored completely)\n  return [items[0]];\n}\n\n// Deep merge: take base from first item, overlay second item's unique fields\nconst branch1 = items[0].json;\nconst branch2 = items[1].json;\n\n// Determine which branch has copywriter and which has artDirector\nconst hasCopywriter1 = !!branch1.pipelineState?.copywriter;\nconst hasArtDirector1 = !!branch1.pipelineState?.artDirector;\nconst hasCopywriter2 = !!branch2.pipelineState?.copywriter;\nconst hasArtDirector2 = !!branch2.pipelineState?.artDirector;\n\n// Merge pipelineState: combine copywriter and artDirector from both branches\nconst mergedPipelineState = {\n  ...branch1.pipelineState,\n  // Take copywriter from whichever branch has it\n  copywriter: branch1.pipelineState?.copywriter || branch2.pipelineState?.copywriter || undefined,\n  // Take artDirector from whichever branch has it\n  artDirector: branch1.pipelineState?.artDirector || branch2.pipelineState?.artDirector || undefined,\n  // Merge agentErrors from both branches\n  agentErrors: [\n    ...(branch1.pipelineState?.agentErrors || []),\n    ...(branch2.pipelineState?.agentErrors || []).filter(\n      e2 => !(branch1.pipelineState?.agentErrors || []).some(e1 => e1.agentName === e2.agentName && e1.timestamp === e2.timestamp)\n    )\n  ]\n};\n\nconst merged = {\n  ...branch1,\n  pipelineState: mergedPipelineState\n};\n\nreturn [{ json: merged }];"
      },
      "id": "merge-parallel",
      "name": "Merge Parallel Branches",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1980, 0]
    },
    {
      "parameters": {
        "source": "database",
        "workflowId": "LecwlmvH4TgejJfh",
        "options": {}
      },
      "id": "agent-jp-localization",
      "name": "JP Localization Agent",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [2200, 0],
      "onError": "continueRegularOutput",
      "notes": "Execute Sub-workflow: jp-localization-agent.json. Sub-workflow handles: JP quality review via build-prompt + Anthropic API, critique loop (max 2 total attempts), Copywriter revision via build-prompt + Anthropic API if rejected, auto-approve on final attempt with flagged status. Returns PipelineState with jpLocalization populated and potentially revised copywriter.variants."
    },
    {
      "parameters": {
        "source": "database",
        "workflowId": "lWOdWcFFdeaPvF9r",
        "options": {}
      },
      "id": "agent-image-generation",
      "name": "Image Generation Agent",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [2420, 0],
      "onError": "continueRegularOutput",
      "notes": "Execute Sub-workflow: image-generation-agent.json. Sub-workflow handles: extract Art Director prompts, call /api/internal/generate-images with HMAC, parse response, send progress callbacks, track costs (~9 yen/image). Returns PipelineState with imageGeneration results. Non-fatal: pipeline continues if generation fails."
    },
    {
      "parameters": {
        "source": "database",
        "workflowId": "bYV8cMkuLEhfYwTo",
        "options": {}
      },
      "id": "agent-compositing",
      "name": "Compositing Agent",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [2640, 0],
      "onError": "continueRegularOutput",
      "notes": "Execute Sub-workflow: compositing-agent.json. Sub-workflow handles: extract generated images + copy variant A, call /api/internal/composite with HMAC, overlay Japanese text via Sharp + node-canvas + BudouX, send progress callbacks. Returns PipelineState with compositing results. Non-fatal: base images still available without compositing."
    },
    {
      "parameters": {
        "source": "database",
        "workflowId": "f3s0fuunFBBPrCBH",
        "options": {}
      },
      "id": "agent-platform-resize",
      "name": "Platform Resize Agent",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [2860, 0],
      "onError": "continueRegularOutput",
      "notes": "Execute Sub-workflow: resize-agent.json. Sub-workflow handles: extract platforms from brief + source assets, call /api/internal/resize with HMAC, smart crop or letterbox based on aspect ratio, upload to Supabase, send progress callbacks. Returns PipelineState with platformResize results. Non-fatal: composited images still available without resize."
    },
    {
      "parameters": {
        "jsCode": "// Final Callback: Send 'complete' status with full pipelineState\n// This marks the campaign as complete with copy + images.\n// Video pipeline runs ASYNCHRONOUSLY after this callback.\n\nconst crypto = require('crypto');\n\nconst input = $input.first().json;\nconst callbackUrl = $env.NEXTJS_CALLBACK_URL;\nconst secret = $env.N8N_WEBHOOK_SECRET;\n\nif (!callbackUrl) {\n  throw new Error('NEXTJS_CALLBACK_URL environment variable is not set');\n}\n\n// Mark pipeline as complete (copy + images delivered)\nconst pipelineState = {\n  ...input.pipelineState,\n  status: 'complete',\n  completedAt: new Date().toISOString()\n};\n\nconst payload = {\n  campaignId: input.campaignId,\n  status: 'success',\n  pipelineVersion: 'v1.1',\n  pipelineState\n};\n\nconst body = JSON.stringify(payload);\nconst signature = crypto\n  .createHmac('sha256', secret)\n  .update(body)\n  .digest('hex');\n\nconst response = await fetch(callbackUrl, {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n    'X-Signature': signature\n  },\n  body\n});\n\nif (!response.ok) {\n  console.warn(`Final callback failed: HTTP ${response.status}`);\n}\n\n// Pass through all data for the async video pipeline fork\nreturn [{ json: { ...input, pipelineState } }];"
      },
      "id": "final-callback",
      "name": "Final Callback - Complete (Copy+Images)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3080, 0]
    },
    {
      "parameters": {
        "jsCode": "// Prepare data for async Video Pipeline sub-workflow\n// Extracts composited image URLs and copy text needed by the video endpoint\n\nconst input = $input.first().json;\nconst pipelineState = input.pipelineState || {};\n\n// Collect composited image URLs from pipeline results\n// These come from the compositing step stored in campaign assets\nconst compositedImageUrls = input.compositedImageUrls || [];\n\nreturn [{\n  json: {\n    campaignId: input.campaignId,\n    brief: input.brief,\n    brandProfile: input.brandProfile,\n    pipelineState: pipelineState,\n    compositedImageUrls: compositedImageUrls\n  }\n}];"
      },
      "id": "prepare-video-data",
      "name": "Prepare Video Pipeline Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3300, 0]
    },
    {
      "parameters": {
        "source": "database",
        "workflowId": "6Gx8don549sVraC7",
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "id": "agent-video-pipeline",
      "name": "Video Pipeline Agent (Async)",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [3520, 0],
      "onError": "continueRegularOutput",
      "notes": "Execute Sub-workflow: video-pipeline-agent.json with waitForSubWorkflow: false (ASYNC). The orchestrator does NOT wait for video generation. Campaign is already marked complete with copy + images. Video assets arrive later via the sub-workflow's own callbacks to the Next.js dashboard (Supabase Realtime)."
    }
  ],
  "connections": {
    "Webhook - Campaign Pipeline": {
      "main": [
        [
          { "node": "Respond to Webhook", "type": "main", "index": 0 },
          { "node": "HMAC Verification", "type": "main", "index": 0 }
        ]
      ]
    },
    "HMAC Verification": {
      "main": [
        [
          { "node": "Initialize PipelineState", "type": "main", "index": 0 }
        ]
      ]
    },
    "Initialize PipelineState": {
      "main": [
        [
          { "node": "Strategic Insight Agent", "type": "main", "index": 0 }
        ]
      ]
    },
    "Strategic Insight Agent": {
      "main": [
        [
          { "node": "Creative Director Agent", "type": "main", "index": 0 }
        ]
      ]
    },
    "Creative Director Agent": {
      "main": [
        [
          { "node": "Copywriter Agent", "type": "main", "index": 0 },
          { "node": "Art Director Agent", "type": "main", "index": 0 }
        ]
      ]
    },
    "Copywriter Agent": {
      "main": [
        [
          { "node": "Merge Parallel Branches", "type": "main", "index": 0 }
        ]
      ]
    },
    "Art Director Agent": {
      "main": [
        [
          { "node": "Merge Parallel Branches", "type": "main", "index": 0 }
        ]
      ]
    },
    "Merge Parallel Branches": {
      "main": [
        [
          { "node": "JP Localization Agent", "type": "main", "index": 0 }
        ]
      ]
    },
    "JP Localization Agent": {
      "main": [
        [
          { "node": "Image Generation Agent", "type": "main", "index": 0 }
        ]
      ]
    },
    "Image Generation Agent": {
      "main": [
        [
          { "node": "Compositing Agent", "type": "main", "index": 0 }
        ]
      ]
    },
    "Compositing Agent": {
      "main": [
        [
          { "node": "Platform Resize Agent", "type": "main", "index": 0 }
        ]
      ]
    },
    "Platform Resize Agent": {
      "main": [
        [
          { "node": "Final Callback - Complete (Copy+Images)", "type": "main", "index": 0 }
        ]
      ]
    },
    "Final Callback - Complete (Copy+Images)": {
      "main": [
        [
          { "node": "Prepare Video Pipeline Data", "type": "main", "index": 0 }
        ]
      ]
    },
    "Prepare Video Pipeline Data": {
      "main": [
        [
          { "node": "Video Pipeline Agent (Async)", "type": "main", "index": 0 }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "meta": {
    "description": "v1.1 Master Orchestrator workflow. Receives campaign brief via webhook, initializes PipelineState, dispatches to agent sub-workflows sequentially (with Copywriter/Art Director in parallel), and reports progress back to Next.js dashboard.",
    "templateCredsSetupCompleted": true,
    "instanceId": "ai-content-studio",
    "notes": "IMPORT INSTRUCTIONS: 1) Set N8N_WEBHOOK_SECRET env var, 2) Set NEXTJS_CALLBACK_URL env var, 3) Set NEXTJS_BASE_URL env var, 4) Activate workflow after import. All agent stubs replaced with Execute Sub-workflow nodes. Video Pipeline runs ASYNC after campaign completion callback (waitForSubWorkflow: false)."
  }
}
