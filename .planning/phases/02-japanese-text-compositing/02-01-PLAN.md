---
phase: 02-japanese-text-compositing
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/lib/compositing/types.ts
  - src/lib/constants/kinsoku-chars.ts
  - src/lib/compositing/kinsoku.ts
  - src/lib/compositing/__tests__/kinsoku.test.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Japanese text is segmented into semantic phrases before line-breaking"
    - "No JIS X 4051 prohibited character appears at line start (closing brackets, punctuation, small kana)"
    - "No JIS X 4051 prohibited character appears at line end (opening brackets, currency symbols)"
    - "Line-breaking respects maxWidth constraint based on font size"
    - "Kinsoku pushforward/pullback resolves without infinite loops"
  artifacts:
    - path: "src/lib/compositing/types.ts"
      provides: "Compositing type definitions for all Phase 2 modules"
      contains: "TextElement"
    - path: "src/lib/constants/kinsoku-chars.ts"
      provides: "JIS X 4051 prohibited character sets"
      contains: "KINSOKU_NOT_AT_LINE_START"
    - path: "src/lib/compositing/kinsoku.ts"
      provides: "Japanese line-breaking engine"
      exports: ["breakJapaneseText"]
    - path: "src/lib/compositing/__tests__/kinsoku.test.ts"
      provides: "Line-breaking test suite"
      contains: "describe"
  key_links:
    - from: "src/lib/compositing/kinsoku.ts"
      to: "budoux"
      via: "loadDefaultJapaneseParser import"
      pattern: "import.*budoux"
    - from: "src/lib/compositing/kinsoku.ts"
      to: "src/lib/constants/kinsoku-chars.ts"
      via: "character set import"
      pattern: "import.*kinsoku-chars"
---

<objective>
Build the compositing type system and kinsoku shori line-breaking engine with TDD.

Purpose: Kinsoku shori (line-breaking rules) is the foundation of correct Japanese text compositing. Every other compositing module depends on types.ts for shared interfaces. BudouX provides semantic phrase segmentation; custom kinsoku rules enforce JIS X 4051 compliance on top of that. This is the competitive moat -- professional-quality Japanese typography.

Output: Tested kinsoku line-breaking engine, compositing type definitions, JIS X 4051 character sets, budoux installed.
</objective>

<execution_context>
@/Users/hani/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-japanese-text-compositing/02-RESEARCH.md
@.planning/phases/01-foundation-core-pipeline/01-01-SUMMARY.md
@.planning/phases/01-foundation-core-pipeline/01-04-SUMMARY.md
@src/lib/db/schema.ts
@src/lib/constants/fonts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create type definitions + kinsoku character sets</name>
  <files>
    package.json
    src/lib/compositing/types.ts
    src/lib/constants/kinsoku-chars.ts
  </files>
  <action>
    1. Install dependencies:
       ```bash
       pnpm add budoux @fontsource/noto-sans-jp
       ```

    2. Create `src/lib/compositing/types.ts` with all shared type definitions for Phase 2 compositing:

       - `TextElement`: text, x, y, fontSize, fontFamily, color, maxWidth, align ('left'|'center'|'right')
       - `TextRole`: 'headline' | 'tagline' | 'cta'
       - `TextOrientation`: 'horizontal' | 'vertical'
       - `ContrastTreatment`: { type: 'backdrop'|'stroke'|'shadow', opacity?, strokeColor?, strokeWidth?, shadowOffset?, shadowBlur? }
       - `LayoutAlternative`: { id: string ('A'|'B'|'C'), headline: TextPlacement, tagline: TextPlacement|null, cta: TextPlacement, logo: {x,y}|null, orientation: TextOrientation, contrastZones: ContrastZone[] }
       - `TextPlacement`: { x, y, maxWidth, align }
       - `ContrastZone`: { region: {x,y,width,height}, brightness: 'light'|'dark'|'mixed' }
       - `LineBreakResult`: { lines: string[], orientation: TextOrientation }
       - `CompositingInput`: { baseImageBuffer: Buffer, imageWidth: number, imageHeight: number, headline: string, tagline: string|null, cta: string, fontFamily: string, brandColors: {primary: string, accent: string}, logoBuffer: Buffer|null }
       - `CompositingResult`: { composites: Array<{ layoutId: string, imageBuffer: Buffer, metadata: LayoutMetadata }> }
       - `LayoutMetadata`: { layoutId, orientation, headline: {text, x, y, fontSize, lines}, tagline?: {text, x, y, fontSize, lines}, cta: {text, x, y, fontSize}, logo?: {x, y, width}, treatment: ContrastTreatment, fontFamily, brandColors, baseImageAssetId: string }
       - `RegionStats`: { luminance: number, variance: number }

    3. Create `src/lib/constants/kinsoku-chars.ts` with JIS X 4051 prohibited character sets:

       - `KINSOKU_NOT_AT_LINE_START`: Set containing closing brackets (）〕〉》」』】〗〞)]}> ), periods/commas (。．、，.,), question/exclamation marks (：；？！:;?!), small kana (ーぁぃぅぇぉっゃゅょゎァィゥェォッャュョヮヵヶ), iteration marks (ヽヾゝゞ々〻), percent/degree (%％°℃)

       - `KINSOKU_NOT_AT_LINE_END`: Set containing opening brackets (（〔〈《「『【〖〝([{<), currency symbols (¥￥$＄£￡)

       Export both as named exports. Use `Set<string>` type. Include a brief JSDoc explaining JIS X 4051 compliance.
  </action>
  <verify>
    - `pnpm build` passes
    - `ls node_modules/budoux` confirms budoux is installed
    - `ls node_modules/@fontsource/noto-sans-jp` confirms font package is installed
    - types.ts exports all interfaces without errors
    - kinsoku-chars.ts exports both character sets
  </verify>
  <done>
    budoux and @fontsource/noto-sans-jp installed. types.ts contains all compositing interfaces. kinsoku-chars.ts contains JIS X 4051 character sets ready for use by the line-breaking engine.
  </done>
</task>

<feature>
  <name>Task 2: Build kinsoku line-breaking engine with TDD</name>
  <files>
    src/lib/compositing/kinsoku.ts
    src/lib/compositing/__tests__/kinsoku.test.ts
  </files>
  <behavior>
    `breakJapaneseText(text, maxWidthPx, fontSize, orientation?)` takes Japanese text and line-break constraints, returns `LineBreakResult` with correctly broken lines.

    The function:
    1. Uses BudouX `loadDefaultJapaneseParser().parse(text)` to segment text into semantic phrases
    2. Estimates characters per line from maxWidthPx / fontSize (Japanese characters are approximately 1em wide)
    3. Assembles lines by accumulating phrases until exceeding charsPerLine
    4. Applies kinsoku shori rules at each line break:
       - If the first character of the next line is in KINSOKU_NOT_AT_LINE_START, pull it back to the current line (pullback)
       - If the last character of the current line is in KINSOKU_NOT_AT_LINE_END, push it forward to the next line (pushforward)
    5. Handles cascade: pushforward/pullback may trigger new violations, max 3 iterations before accepting
    6. Returns { lines, orientation } where orientation defaults to 'horizontal'

    Test cases (RED phase - write these first):

    **Basic segmentation:**
    - Input: "新春セールスタート", width=400, size=40 -> single line (10 chars * 40px = 400px fits)
    - Input: "新春セール開催中！今だけの特別価格でお買い求めいただけます", width=400, size=40 -> multiple lines

    **Kinsoku line-start prohibition:**
    - "商品の紹介です。詳細はこちら" -> the period 。 must NOT appear at the start of a line; pull it back to previous line
    - "セール開催中！お見逃しなく" -> ! must NOT appear at the start of a line

    **Kinsoku line-end prohibition:**
    - "今すぐ（期間限定）購入" -> opening bracket （ must NOT appear at the end of a line; push it forward

    **Small kana:**
    - "チャンス" -> if break occurs, ャ must not be at line start

    **Edge cases:**
    - Empty string -> { lines: [], orientation: 'horizontal' }
    - Single character -> { lines: ['X'], orientation: 'horizontal' }
    - Text shorter than one line -> single line output
    - Very narrow width (less than 6 chars) -> lines may exceed width slightly to satisfy kinsoku

    **Orientation passthrough:**
    - orientation='vertical' is passed through to result without affecting line-breaking logic (vertical rendering handled by vertical-text.ts)
  </behavior>
  <implementation>
    Import `loadDefaultJapaneseParser` from 'budoux'. Import `KINSOKU_NOT_AT_LINE_START`, `KINSOKU_NOT_AT_LINE_END` from '@/lib/constants/kinsoku-chars'. Import `LineBreakResult`, `TextOrientation` from './types'.

    Create the parser once at module level: `const parser = loadDefaultJapaneseParser()`.

    Implement `breakJapaneseText()` following the algorithm described in behavior. Key implementation details:
    - Use `parser.parse(text)` for initial phrase segmentation (BudouX returns string array of phrases)
    - Character width estimation: assume each CJK character = fontSize, each ASCII character = fontSize * 0.5
    - For kinsoku correction, implement a `resolveKinsoku(lines)` post-processing pass with max 3 iterations
    - Export as named export

    Also export a helper `estimateTextWidth(text: string, fontSize: number): number` that estimates pixel width of a Japanese text string (useful for other modules).
  </implementation>
</feature>

</tasks>

<verification>
- `pnpm test src/lib/compositing/__tests__/kinsoku.test.ts` passes all test cases
- `pnpm build` compiles without errors
- kinsoku.ts properly segments Japanese text and enforces JIS X 4051 rules
- No prohibited characters appear at line start/end in test outputs
</verification>

<success_criteria>
- budoux and @fontsource/noto-sans-jp installed and importable
- types.ts defines all compositing interfaces (TextElement, LayoutAlternative, CompositingInput, CompositingResult, etc.)
- kinsoku-chars.ts contains complete JIS X 4051 character sets
- kinsoku.ts `breakJapaneseText()` passes all TDD test cases including kinsoku edge cases
- All tests pass: `pnpm test` exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/02-japanese-text-compositing/02-01-SUMMARY.md`
</output>
