---
phase: 02-japanese-text-compositing
plan: 04
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - src/lib/compositing/index.ts
  - src/app/api/campaigns/route.ts
  - src/app/api/webhooks/n8n/route.ts
  - src/lib/db/schema.ts
  - src/components/campaign/image-tab.tsx
autonomous: true

must_haves:
  truths:
    - "System composites Japanese text onto AI-generated base images with correct Noto Sans JP typography"
    - "Text overlay follows kinsoku shori line-break rules"
    - "Brand kit colors, logo, and font preferences are applied to composited images"
    - "System generates 3 layout alternatives per image with different text positions"
    - "Composited images are stored in Supabase Storage and referenced in assets table"
    - "Campaign generation pipeline includes compositing as a stage after image generation"
    - "Composited images display in the campaign results image tab"
  artifacts:
    - path: "src/lib/compositing/index.ts"
      provides: "Main compositing pipeline orchestrator"
      exports: ["compositeCampaignImages"]
    - path: "src/app/api/campaigns/route.ts"
      provides: "Updated campaign creation with compositing stage"
      contains: "compositeCampaignImages"
    - path: "src/components/campaign/image-tab.tsx"
      provides: "Updated image tab showing composited images"
      contains: "composited_image"
  key_links:
    - from: "src/lib/compositing/index.ts"
      to: "src/lib/compositing/layout-engine.ts"
      via: "analyzeImageLayout import for layout intelligence"
      pattern: "import.*analyzeImageLayout.*layout-engine"
    - from: "src/lib/compositing/index.ts"
      to: "src/lib/compositing/kinsoku.ts"
      via: "breakJapaneseText import for line breaking"
      pattern: "import.*breakJapaneseText.*kinsoku"
    - from: "src/lib/compositing/index.ts"
      to: "src/lib/compositing/text-renderer.ts"
      via: "buildTextSvg import for SVG overlay generation"
      pattern: "import.*buildTextSvg.*text-renderer"
    - from: "src/lib/compositing/index.ts"
      to: "src/lib/compositing/contrast-analyzer.ts"
      via: "analyzeRegionContrast import for readability analysis"
      pattern: "import.*analyzeRegionContrast.*contrast-analyzer"
    - from: "src/app/api/campaigns/route.ts"
      to: "src/lib/compositing/index.ts"
      via: "Dynamic import of compositeCampaignImages in generation pipeline"
      pattern: "import.*compositing"
---

<objective>
Build the compositing pipeline orchestrator and wire it into the campaign generation flow.

Purpose: This is the integration plan that connects all compositing modules (kinsoku, text renderer, vertical text, contrast analyzer, logo placer, layout engine) into a single pipeline, stores composited images in Supabase Storage, and hooks into the existing campaign generation flow. After this plan, submitting a campaign brief produces composited images with Japanese text overlaid on AI-generated base images -- the core Phase 2 deliverable.

Output: Working end-to-end compositing pipeline integrated into campaign generation.
</objective>

<execution_context>
@/Users/hani/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-japanese-text-compositing/02-RESEARCH.md
@.planning/phases/02-japanese-text-compositing/02-01-SUMMARY.md
@.planning/phases/02-japanese-text-compositing/02-02-SUMMARY.md
@.planning/phases/02-japanese-text-compositing/02-03-SUMMARY.md
@src/lib/compositing/types.ts
@src/lib/compositing/kinsoku.ts
@src/lib/compositing/contrast-analyzer.ts
@src/lib/compositing/text-renderer.ts
@src/lib/compositing/vertical-text.ts
@src/lib/compositing/logo-placer.ts
@src/lib/compositing/layout-engine.ts
@src/app/api/campaigns/route.ts
@src/app/api/webhooks/n8n/route.ts
@src/components/campaign/image-tab.tsx
@src/lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build compositing pipeline orchestrator and storage integration</name>
  <files>
    src/lib/compositing/index.ts
    src/lib/db/schema.ts
  </files>
  <action>
    **src/lib/compositing/index.ts:**

    Create the main compositing pipeline orchestrator:

    1. `compositeCampaignImages(params): Promise<CompositingResult[]>` -- orchestrates compositing for all campaign images:
       - Parameters:
         ```typescript
         {
           campaignId: string,
           baseImages: Array<{ assetId: string, url: string, width: number, height: number }>,
           copyVariant: { headline: string, bodyText: string, ctaText: string },
           brandProfile: { fontPreference: string, colors: BrandColors | null, logoUrl: string | null },
           onProgress?: (percent: number, step: string) => Promise<void>
         }
         ```
       - Pipeline steps per image:
         a. Fetch the base image buffer from URL: `const response = await fetch(url); const buffer = Buffer.from(await response.arrayBuffer())`
         b. Fetch logo buffer if brandProfile.logoUrl exists (same fetch pattern)
         c. Resolve font family: look up brandProfile.fontPreference in JAPANESE_FONTS constant (from '@/lib/constants/fonts'), use nameEn as fontFamily. Fall back to 'Noto Sans JP' if not found (per locked decision)
         d. Determine if tagline should be included: use bodyText as tagline if it's <= 30 characters, otherwise null (tagline is optional per locked decision "System omits tagline when the format doesn't warrant it")
         e. Call `analyzeImageLayout()` to get 3 layout alternatives
         f. For each layout alternative (3 per image):
            - Calculate font sizes: baseFontSize = Math.round(imageWidth / 16), headlineSize = baseFontSize, taglineSize = Math.round(baseFontSize * 0.6), ctaSize = Math.round(baseFontSize * 0.7) (per locked ratio-based hierarchy)
            - Break headline text with `breakJapaneseText(headline, layout.headline.maxWidth, headlineSize, layout.orientation)`
            - Break tagline if present with same function
            - Analyze contrast for headline region with `analyzeRegionContrast()`
            - Select contrast treatment with `selectContrastTreatment()`
            - Determine text color: white (#FFFFFF) on dark backgrounds (luminance < 0.5), black (#1A1A1A) on light backgrounds. For CTA, use brand colors per locked decision
            - Build SVG overlays:
              - If orientation === 'vertical': use `buildVerticalTextSvg()` for headline
              - If orientation === 'horizontal': use `buildTextSvg()` for headline
              - Use `buildCtaSvg()` for CTA (always horizontal, per research note that vertical CTAs are not convention)
              - If tagline: use `buildTextSvg()` (always horizontal)
            - Prepare logo overlay with `prepareLogoOverlay()` if logo buffer exists
            - Composite all overlays onto base image using `sharp(baseImageBuffer).composite(overlays).png().toBuffer()`
         g. Store all 3 composited PNGs to Supabase Storage:
            - Bucket: 'composited-images' (will need to be created in Supabase)
            - Path: `{campaignId}/{assetId}-layout-{layoutId}.png`
            - Use adminClient from '@/lib/supabase/admin'
            - Get public URL after upload
         h. Insert composited image assets into the assets table:
            - type: 'composited_image'
            - storageKey: the Supabase Storage path
            - modelUsed: 'sharp-composite'
            - metadata: LayoutMetadata JSON containing all layout info (layoutId, orientation, text positions, treatment, fontFamily, brandColors, baseImageAssetId)
         i. Call onProgress callback with percentage updates
       - Process images in parallel using `Promise.all()` (Sharp compositing is fast; Claude Vision is the bottleneck but is called per-image so parallelizing images helps)
       - Return array of CompositingResult (one per base image)

    2. Error handling:
       - If compositing fails for one image, log error and continue with remaining images (don't fail entire batch)
       - If all images fail, throw with descriptive error
       - Catch and log individual overlay failures (e.g., logo fetch fails) -- compose without the failed element rather than failing the whole image

    **src/lib/db/schema.ts:**

    Update the CampaignProgress interface to include compositing stage:

    ```typescript
    export interface CampaignProgress {
      stage: string
      copyStatus: "pending" | "generating" | "complete" | "failed"
      imageStatus: "pending" | "generating" | "complete" | "failed"
      compositingStatus?: "pending" | "generating" | "complete" | "failed"  // NEW
      percentComplete: number
      currentStep: string
    }
    ```

    This is a non-breaking addition (optional field) -- existing campaigns without compositing continue to work.

    Imports for index.ts:
    - sharp from 'sharp'
    - { analyzeImageLayout } from './layout-engine'
    - { breakJapaneseText } from './kinsoku'
    - { analyzeRegionContrast, selectContrastTreatment } from './contrast-analyzer'
    - { buildTextSvg, buildCtaSvg } from './text-renderer'
    - { buildVerticalTextSvg, shouldUseVerticalText } from './vertical-text'
    - { prepareLogoOverlay } from './logo-placer'
    - { CompositingInput, CompositingResult, LayoutMetadata, BrandColors } from './types'  (add BrandColors import from schema if not in types)
    - { db } from '@/lib/db'
    - { assets } from '@/lib/db/schema'
    - { adminClient } from '@/lib/supabase/admin'
    - { getFontById } from '@/lib/constants/fonts'
  </action>
  <verify>
    - `pnpm build` passes
    - index.ts exports compositeCampaignImages
    - CampaignProgress interface has optional compositingStatus field
    - All compositing module imports resolve
  </verify>
  <done>
    Compositing pipeline orchestrator ties all modules together: fetches base image -> Claude Vision layout -> kinsoku line-breaking -> contrast analysis -> SVG rendering -> Sharp compositing -> Supabase Storage upload -> assets table insert. CampaignProgress supports compositing stage tracking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire compositing into campaign generation pipeline and update image display</name>
  <files>
    src/app/api/campaigns/route.ts
    src/app/api/webhooks/n8n/route.ts
    src/components/campaign/image-tab.tsx
  </files>
  <action>
    **src/app/api/campaigns/route.ts -- update runDirectGeneration():**

    Add compositing as a new stage after image generation, before marking campaign complete:

    1. After image assets are inserted (after the "Insert assets" loop), add compositing stage:
       ```
       // Update progress: compositing
       await db.update(campaigns).set({
         progress: {
           stage: 'compositing',
           copyStatus: 'complete',
           imageStatus: 'complete',
           compositingStatus: 'generating',
           percentComplete: 70,
           currentStep: 'テキスト合成中...',
         }
       }).where(eq(campaigns.id, campaignId))
       ```

    2. Fetch the inserted base image assets for this campaign to get their IDs and URLs:
       ```
       const baseImageAssets = await db.select().from(assets)
         .where(and(eq(assets.campaignId, campaignId), eq(assets.type, 'image')))
       ```

    3. Pick the first copy variant's text for compositing (use the A案 variant):
       ```
       const firstVariant = await db.select().from(copyVariants)
         .where(and(eq(copyVariants.campaignId, campaignId), eq(copyVariants.variantLabel, 'A案')))
         .limit(1)
       ```

    4. Dynamically import and call compositing:
       ```
       const { compositeCampaignImages } = await import('@/lib/compositing')
       await compositeCampaignImages({
         campaignId,
         baseImages: baseImageAssets.map(a => ({
           assetId: a.id,
           url: a.storageKey,  // In Phase 1 this is the Flux URL
           width: parseInt(a.width || '1024'),
           height: parseInt(a.height || '1024'),
         })),
         copyVariant: {
           headline: firstVariant[0]?.headline || '',
           bodyText: firstVariant[0]?.bodyText || '',
           ctaText: firstVariant[0]?.ctaText || '',
         },
         brandProfile: {
           fontPreference: brandProfile.fontPreference || 'noto_sans_jp',
           colors: brandProfile.colors,
           logoUrl: brandProfile.logoUrl,
         },
         onProgress: async (percent, step) => {
           await db.update(campaigns).set({
             progress: {
               stage: 'compositing',
               copyStatus: 'complete',
               imageStatus: 'complete',
               compositingStatus: 'generating',
               percentComplete: 70 + Math.round(percent * 0.25),  // 70-95% range
               currentStep: step,
             }
           }).where(eq(campaigns.id, campaignId))
         },
       })
       ```

    5. Update the completion status to include compositing:
       ```
       progress: {
         stage: 'complete',
         copyStatus: 'complete',
         imageStatus: 'complete',
         compositingStatus: 'complete',
         percentComplete: 100,
         currentStep: '生成完了',
       }
       ```

    6. If compositing fails, don't fail the entire campaign. Catch the error, set compositingStatus to 'failed', and still mark campaign as 'partial' (instead of 'complete') so the user sees base images at minimum:
       ```
       catch (compositingError) {
         console.error('Compositing failed:', compositingError)
         // Campaign still has copy + base images -- mark as partial
         await db.update(campaigns).set({
           status: 'partial',
           progress: { ..., compositingStatus: 'failed', ... }
         })
       }
       ```

    **src/app/api/webhooks/n8n/route.ts -- update webhook handler:**

    After the webhook receives image assets and before marking campaign complete, add the same compositing integration:
    - After image assets are stored, trigger compositing pipeline
    - Use the same compositeCampaignImages call pattern as in runDirectGeneration
    - Update progress with compositing stage
    - Handle compositing failure gracefully (partial completion)

    NOTE: Read the current webhook handler carefully. If it currently just stores results from n8n, add compositing as a post-processing step. If n8n handles all generation, the webhook result handler should trigger compositing after receiving images.

    **src/components/campaign/image-tab.tsx -- update image display:**

    Update the image tab to:
    1. Group images into two sections: "合成画像" (Composited Images) and "ベース画像" (Base Images)
    2. Filter assets by type: `type === 'composited_image'` vs `type === 'image'`
    3. If composited images exist, show them first (prominently) with a section header
    4. Show base images below in a smaller grid (or collapsed accordion) with label "ベース画像（AI生成）"
    5. If no composited images exist (campaign predates Phase 2 or compositing failed), show base images as before (backward compatible)
    6. Each composited image card should show the layout ID label (e.g., "レイアウト A", "レイアウト B", "レイアウト C")
    7. The layout label can be extracted from the asset's metadata.layoutId field

    Keep all existing functionality (download, lightbox zoom) working for both image types.
  </action>
  <verify>
    - `pnpm build` passes
    - campaigns/route.ts runDirectGeneration includes compositing stage with progress updates
    - webhooks/n8n/route.ts includes compositing post-processing
    - image-tab.tsx renders composited images and base images in separate sections
    - Backward compatible: campaigns without composited images display normally
  </verify>
  <done>
    Compositing is wired into the campaign generation pipeline as a stage after image generation. Progress tracking shows compositing status. Image tab displays composited images prominently with layout variant labels. Base images remain visible for reference. Compositing failure degrades gracefully to partial campaign status.
  </done>
</task>

</tasks>

<verification>
- Full pipeline test: submitting a campaign brief triggers copy generation -> image generation -> compositing -> results display
- Composited images appear in the image tab with layout variant labels
- Base images remain accessible below composited images
- CampaignProgress shows compositing stage during generation
- Compositing failure results in 'partial' campaign status (not 'failed')
- `pnpm build` passes without errors
</verification>

<success_criteria>
- compositeCampaignImages() orchestrates the full pipeline: fetch base image -> layout analysis -> line breaking -> contrast analysis -> SVG rendering -> Sharp compositing -> storage upload -> asset insert
- Campaign generation flow includes compositing after image generation with progress updates
- Image tab shows composited images first with layout labels, base images below
- Compositing failure is graceful (partial status, base images still visible)
- All 4 Phase 2 requirements satisfied:
  - IMG-02: Japanese text composited onto AI-generated images (compositeCampaignImages + buildTextSvg)
  - IMG-03: Kinsoku shori line-break rules followed (breakJapaneseText integration)
  - IMG-05: Brand kit colors, logo applied (brand color treatment + prepareLogoOverlay)
  - COPY-02: Keigo register maintained (copy variant text passed through from Phase 1 generation with register control)
- `pnpm build` passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-japanese-text-compositing/02-04-SUMMARY.md`
</output>
