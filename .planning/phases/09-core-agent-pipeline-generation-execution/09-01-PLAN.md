---
phase: 09-core-agent-pipeline-generation-execution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/pipeline.ts
  - src/lib/db/schema.ts
  - src/app/api/webhooks/n8n/route.ts
  - src/components/campaign/generation-progress.tsx
  - src/components/campaign/strategy-accordion.tsx
  - src/app/(dashboard)/campaigns/[id]/campaign-detail-content.tsx
autonomous: true
requirements: [ORCH-02]

must_haves:
  truths:
    - "n8n master orchestrator workflow receives webhook from Next.js, initializes PipelineState, and dispatches to agent sub-workflows sequentially"
    - "Per-agent progress steps with Japanese labels and summary lines appear in the dashboard in real time as agents complete"
    - "Campaign detail page shows a collapsible strategy accordion with plain-language Japanese conclusions (no framework names exposed)"
    - "pipelineState JSONB column on campaigns table stores the complete agent output record after pipeline completion"
  artifacts:
    - path: "src/types/pipeline.ts"
      provides: "AgentStep type, agentSteps array in CampaignProgress, strategy text mapping function"
      contains: "AgentStep"
    - path: "src/lib/db/schema.ts"
      provides: "pipelineState JSONB column on campaigns table"
      contains: "pipelineState"
    - path: "src/app/api/webhooks/n8n/route.ts"
      provides: "agentStep callback handling merged into campaign progress"
      contains: "agentStep"
    - path: "src/components/campaign/generation-progress.tsx"
      provides: "Per-agent vertical timeline with Japanese labels and summary lines"
      contains: "agentSteps"
    - path: "src/components/campaign/strategy-accordion.tsx"
      provides: "Collapsible strategy section with steel-blue accent"
      contains: "StrategyAccordion"
  key_links:
    - from: "n8n master workflow"
      to: "src/app/api/webhooks/n8n/route.ts"
      via: "HTTP POST with agentStep in callback payload"
      pattern: "agentStep.*status"
    - from: "src/app/api/webhooks/n8n/route.ts"
      to: "src/components/campaign/generation-progress.tsx"
      via: "Supabase Realtime on campaigns.progress column"
      pattern: "agentSteps"
    - from: "src/components/campaign/strategy-accordion.tsx"
      to: "campaigns.pipelineState JSONB"
      via: "Server component prop from page query"
      pattern: "strategicInsight"
    - from: "n8n master orchestrator step 9 (Persist CopyVariants Callback)"
      to: "src/app/api/webhooks/n8n/route.ts copyVariants handler"
      via: "HTTP POST with copyVariants as top-level field in callback payload"
      pattern: "copyVariants.*insert"
---

<objective>
Build the n8n master orchestrator workflow and the Next.js infrastructure (types, DB column, callback handler, progress UI, strategy accordion) that supports per-agent progress reporting and strategy visibility.

Purpose: This is the backbone for all Phase 9 plans. The master orchestrator receives the webhook, initializes PipelineState, and dispatches to agent sub-workflows. The Next.js side receives per-agent progress callbacks and displays them in real time.

Output: n8n master orchestrator workflow (created via n8n MCP), updated pipeline types, pipelineState DB column, upgraded progress UI with per-agent timeline, strategy accordion component.
</objective>

<execution_context>
@/Users/hani/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-core-agent-pipeline-generation-execution/09-CONTEXT.md
@.planning/phases/09-core-agent-pipeline-generation-execution/09-RESEARCH.md
@.planning/phases/08-infrastructure-schema-foundation/08-02-SUMMARY.md
@src/types/pipeline.ts
@src/lib/db/schema.ts
@src/app/api/webhooks/n8n/route.ts
@src/components/campaign/generation-progress.tsx
@src/hooks/use-campaign-progress.ts
@src/app/(dashboard)/campaigns/[id]/campaign-detail-content.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AgentStep types, pipelineState column, and callback handler updates</name>
  <files>
    src/types/pipeline.ts
    src/lib/db/schema.ts
    src/app/api/webhooks/n8n/route.ts
  </files>
  <action>
**1. Extend `src/types/pipeline.ts`:**

Add the `AgentStep` interface after the `PipelineMilestone` interface:

```typescript
export interface AgentStep {
  agentName: "strategic_insight" | "creative_director" | "copywriter" | "art_director" | "jp_localization" | "asset_generation"
  labelJa: string
  status: "pending" | "active" | "complete" | "failed" | "flagged"
  summaryJa?: string  // 1-2 line Japanese summary on completion
  startedAt?: string  // ISO timestamp
  completedAt?: string
}
```

Add an `AGENT_STEP_DEFINITIONS` constant with the 6 agents and their Japanese labels (from CONTEXT.md decisions):
- strategic_insight: "戦略分析中"
- creative_director: "クリエイティブ設計中"
- copywriter: "コピーライティング中"
- art_director: "アート設計中"
- jp_localization: "JP品質確認中"
- asset_generation: "アセット生成中"

Add `agentStep?: AgentStep` to the `N8nCallbackPayload` interface.

Add a `strategyToJapanese(insight: StrategicInsightOutput): string` function that maps internal strategic insight data to plain-language Japanese conclusions. This function:
- Takes LF8 desires and maps them to human-readable Japanese descriptions (e.g., "survival" -> "安全・安心への欲求", "social_approval" -> "社会的承認への欲求")
- Combines awareness level context + LF8 mapping + tonal guidance into 2-3 natural Japanese sentences
- NEVER includes framework names (Schwartz, LF8, PAS, AIDA, SB7), codes, or classification labels
- Example output: "このキャンペーンは、お客様の安心感への欲求に訴えかけるアプローチを採用。温かみのあるトーンで家族の絆を強調。"
- Include a lookup map for the 8 LF8 desires to Japanese descriptions

**2. Extend `src/lib/db/schema.ts`:**

In the `CampaignProgress` interface, add:
```typescript
agentSteps?: import("@/types/pipeline").AgentStep[]
```

Add a `pipelineState` JSONB column to the `campaigns` table:
```typescript
pipelineState: jsonb("pipeline_state").$type<import("@/types/pipeline").PipelineState>(),
```

Create a migration SQL file at `src/lib/db/migrations/0002_add-pipeline-state-column.sql`:
```sql
ALTER TABLE campaigns ADD COLUMN pipeline_state JSONB;
```

**3. Extend `src/app/api/webhooks/n8n/route.ts`:**

Add handling for the `agentStep` field in the callback payload. After the existing milestone handling block, add:

```typescript
// Handle v1.1 per-agent step updates
if (payload.agentStep) {
  const currentCampaign = await db
    .select({ progress: campaigns.progress })
    .from(campaigns)
    .where(eq(campaigns.id, campaignId))
    .limit(1)

  const existingProgress = (currentCampaign[0]?.progress ?? {}) as CampaignProgress
  const agentSteps = existingProgress.agentSteps || []

  // Update existing step or add new one
  const stepIndex = agentSteps.findIndex(s => s.agentName === payload.agentStep!.agentName)
  if (stepIndex >= 0) {
    agentSteps[stepIndex] = { ...agentSteps[stepIndex], ...payload.agentStep }
  } else {
    agentSteps.push(payload.agentStep)
  }

  await db
    .update(campaigns)
    .set({
      progress: {
        ...existingProgress,
        agentSteps,
      } as CampaignProgress,
    })
    .where(eq(campaigns.id, campaignId))
}
```

Also add handling for `pipelineState` in the callback -- when `status === "success"` or `status === "partial"`, persist `payload.pipelineState` to the new `pipelineState` column:

```typescript
if (payload.pipelineState) {
  await db
    .update(campaigns)
    .set({ pipelineState: payload.pipelineState })
    .where(eq(campaigns.id, campaignId))
}
```

Add `agentStep` to the local `N8nWebhookPayload` interface inside this file to match the updated type.

  </action>
  <verify>
Run `npx tsc --noEmit` from the project root -- should compile clean with no errors related to AgentStep, pipelineState, or the updated callback handler.
  </verify>
  <done>
AgentStep type exists with all 6 agent definitions. CampaignProgress has agentSteps array. Campaigns table has pipelineState JSONB column. Callback handler merges agentStep updates into progress and persists pipelineState on completion. strategyToJapanese function maps internal codes to user-friendly Japanese prose without exposing framework names.
  </done>
</task>

<task type="auto">
  <name>Task 2: Upgrade progress UI and create strategy accordion</name>
  <files>
    src/components/campaign/generation-progress.tsx
    src/components/campaign/strategy-accordion.tsx
    src/app/(dashboard)/campaigns/[id]/campaign-detail-content.tsx
  </files>
  <action>
**1. Rewrite `src/components/campaign/generation-progress.tsx`:**

Replace the flat step indicator UI with a **vertical timeline** that shows per-agent progress. The component should:

- Read `progress.agentSteps` (the new array) alongside the existing v1.0 fields
- If `progress.pipelineVersion === "v1.1"` AND `agentSteps` is present, render the v1.1 per-agent timeline. Otherwise, fall back to the existing v1.0 flat step display (backward compat).
- **v1.1 timeline layout:**
  - Vertical list with a connecting line between steps (use a `border-l-2` on a wrapper div)
  - Each step row: status icon (left) + agent label in Japanese (center) + summary line (right, appears on completion)
  - Status icons: pending = gray circle outline, active = vermillion spinning Loader2, complete = green CheckCircle2, failed = red AlertCircle, flagged = amber AlertTriangle
  - Active step: label in `font-medium text-text-primary`, pulsing dot indicator
  - Complete step: label in `text-success`, summary line in `text-sm text-text-muted` appearing below the label
  - For long-running active steps: show elapsed timer next to the spinner. Calculate from `step.startedAt` using `Date.now() - new Date(startedAt).getTime()`. Update every second via `setInterval` in a `useEffect`. Format as "M:SS" (e.g., "1:23").
- Keep the overall progress bar at the top (calculate percentage from completed agent steps: each of 6 agents = ~16.67%)
- Keep the "リアルタイムで更新中" indicator at the bottom
- All text in Japanese, zero English visible

**2. Create `src/components/campaign/strategy-accordion.tsx`:**

A new client component that renders the strategy insight as a collapsible accordion.

```typescript
"use client"

import { useState } from "react"
import { ChevronDown } from "lucide-react"
import { cn } from "@/lib/utils"
import type { StrategicInsightOutput } from "@/types/pipeline"
import { strategyToJapanese } from "@/types/pipeline"

interface StrategyAccordionProps {
  strategicInsight: StrategicInsightOutput
}
```

Design per Context decisions:
- **Collapsed by default** (useState false)
- **Steel-blue accent** color: `#6B8FA3` -- use as left border and icon color
- Placement: between campaign header and tab bar (added via campaign-detail-content.tsx)
- Collapsed state: single row with "戦略的アプローチ" label + ChevronDown icon + steel-blue left border
- Expanded state: smooth height transition (`max-height` + `overflow-hidden` + `transition-all duration-300 ease-in-out`), shows 2-3 lines of strategy summary text from `strategyToJapanese(strategicInsight)`
- Text style: `text-sm text-text-secondary leading-relaxed`
- Click anywhere on the header row to toggle

**3. Integrate strategy accordion into `src/app/(dashboard)/campaigns/[id]/campaign-detail-content.tsx`:**

- Import `StrategyAccordion` component
- Read `campaign.pipelineState` (the new JSONB column) from the campaign prop
- If `pipelineState?.strategicInsight` exists, render `<StrategyAccordion strategicInsight={pipelineState.strategicInsight} />` between the campaign header section and the tab bar
- Only render for v1.1 pipeline campaigns (check `pipelineState?.version === "v1.1"`)

  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile clean. Visually inspect: the generation-progress component should render a vertical timeline with Japanese agent labels when agentSteps data is present. The strategy accordion should render in collapsed state with steel-blue accent.
  </verify>
  <done>
GenerationProgress component shows per-agent vertical timeline with Japanese labels, summary lines, and elapsed timer for active steps (v1.1 mode), with v1.0 flat step fallback preserved. StrategyAccordion component renders between campaign header and tab bar, collapsed by default with steel-blue accent, expanding to show plain-language Japanese strategy conclusions. No English text or framework names visible in any user-facing component.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create n8n master orchestrator workflow</name>
  <files>
    (n8n workflow via MCP tools -- no local files)
  </files>
  <action>
Create the master orchestrator workflow in n8n using the `mcp__n8n-mcp__n8n_create_workflow` tool.

**Workflow structure:**

1. **Webhook node** (trigger):
   - Method: POST
   - Path: `/campaign-pipeline` (this becomes the N8N_WEBHOOK_URL endpoint)
   - Response mode: "Respond to Webhook" -- immediately return 200 to Next.js, then process async
   - Authentication: None (HMAC verified in Code node)

2. **HMAC Verify (Code node):**
   - Reads `X-Signature` from headers
   - Computes HMAC-SHA256 of body using `N8N_WEBHOOK_SECRET` (from n8n credentials or environment)
   - If signature mismatch: throw error (stops workflow)
   - Passes through the parsed webhook payload

3. **Initialize PipelineState (Code node):**
   - Creates PipelineState object from webhook payload:
     ```javascript
     const payload = $input.first().json;
     return {
       json: {
         pipelineState: {
           version: "v1.1",
           campaignId: payload.campaignId,
           mode: payload.mode || "pro",
           status: "running",
           agentErrors: [],
           startedAt: new Date().toISOString()
         },
         brief: payload.brief,
         brandProfile: payload.brandProfile,
         agentConfig: payload.agentConfig,
         callbackUrl: "<NEXT_JS_CALLBACK_URL>",  // The Next.js /api/webhooks/n8n endpoint
         webhookSecret: "<N8N_WEBHOOK_SECRET>"
       }
     };
     ```

4. **Progress Callback: Strategy Active (HTTP Request node):**
   - POST to callback URL with HMAC signature
   - Body: `{ campaignId, status: "progress", agentStep: { agentName: "strategic_insight", labelJa: "戦略分析中", status: "active", startedAt } }`
   - This node is a reusable pattern -- each agent gets a "start" and "complete" callback pair

5. **Execute Sub-workflow: Strategic Insight** (placeholder -- sub-workflow created in plan 09-02)
   - Passes full pipelineState + brief + brandProfile + agentConfig
   - Wait for completion

6. **Quality Gate (Code node):**
   - Validates strategicInsight output: awarenessLevel non-empty, lf8Desires.length >= 1, copywritingFramework is PAS/AIDA/BAB/SB7, targetInsight.length >= 10, creativeDirection.length >= 10
   - On failure: sends error callback with `{ status: "failure", agentError: { agentName: "strategic_insight", isCriticalStop: true, message: "戦略分析を完了できませんでした。お手数ですが、もう一度お試しください。" } }`

7. **Execute Sub-workflow: Creative Director** (placeholder -- 09-02)

8. **Parallel branch (Split In Batches or separate branches):**
   - Branch A: Execute Sub-workflow: Copywriter -> Execute Sub-workflow: JP Localization
   - Branch B: Execute Sub-workflow: Art Director
   - Merge after both complete

9. **Persist CopyVariants Callback (HTTP Request node) — CRITICAL DATA BRIDGE:**
   - After the parallel merge (step 8) completes and before dispatching to Flux image gen (step 10), send an intermediate progress callback to Next.js that includes `copyVariants` as a **top-level field** in the payload.
   - The existing webhook handler at `/api/webhooks/n8n/route.ts` already handles top-level `copyVariants` by inserting them into the `copyVariants` relational table (lines 223-226 of existing code).
   - This step bridges the gap: the v1.1 pipeline stores Copywriter output in `pipelineState.copywriter.variants` (JSONB), but the compositing endpoint (plan 09-04) queries the `copyVariants` SQL table. Without this step, the `copyVariants` table would be empty for v1.1 campaigns and compositing would fail.
   - **Code node before the HTTP Request:** Extract and transform copywriter variants from pipelineState:
     ```javascript
     const ps = $input.first().json.pipelineState;
     const variants = ps.copywriter?.variants || [];
     // Transform to the CopyVariantPayload[] shape the webhook handler expects
     const copyVariants = variants.map(v => ({
       platform: v.platform,
       variantLabel: v.variantLabel,
       headline: v.headline,
       bodyText: v.body,
       ctaText: v.cta,
       hashtags: v.hashtags,
       register: v.register,
     }));
     return {
       json: {
         ...($input.first().json),
         copyVariantsPayload: copyVariants,
       }
     };
     ```
   - **HTTP Request:** POST to callbackUrl with HMAC signature
   - Body: `{ campaignId, status: "progress", copyVariants: copyVariantsPayload }`
   - This ensures the `copyVariants` relational table is populated before compositing executes.

10. **Execute Sub-workflow: Image Generation** (placeholder -- 09-04)

11. **Execute Sub-workflow: Compositing** (placeholder -- 09-04)

12. **Execute Sub-workflow: Platform Resize** (placeholder -- 09-04)

13. **Final Callback: Campaign Complete (HTTP Request node):**
    - POST: `{ campaignId, status: "success", pipelineState: <full state>, pipelineVersion: "v1.1", copyVariants: <from pipelineState.copywriter.variants> }`
    - NOTE: `copyVariants` is also included here as a safety net, but the primary persistence happens in step 9 before image generation.

14. **Async Fork: Video Pipeline** (Execute Sub-workflow with waitForSubWorkflow: false -- placeholder 09-05)

**Error handling:** Each Execute Sub-workflow node should have:
- `onError: "continue"` for partial-delivery agents (Copywriter, Art Director, JP Localization)
- `onError: "stop"` for critical-stop agents (Strategic Insight, Creative Director)
- After each sub-workflow, a Code node checks for errors and routes accordingly

**Progress callback pattern:** Create a reusable Code node function (or a helper sub-workflow) that:
1. Takes (campaignId, callbackUrl, webhookSecret, payloadBody)
2. Computes HMAC-SHA256 signature
3. POSTs to callbackUrl with X-Signature header
This is called before and after each agent sub-workflow.

**NOTE:** Sub-workflow IDs are placeholders. After plans 09-02 through 09-05 create the actual sub-workflows, the master orchestrator will be updated via `mcp__n8n-mcp__n8n_update_partial_workflow` to reference the correct sub-workflow IDs.

Record the created workflow ID in the SUMMARY for use by subsequent plans.

  </action>
  <verify>
The n8n workflow is created and visible via `mcp__n8n-mcp__n8n_get_workflow`. The workflow has a webhook trigger, HMAC verification, PipelineState initialization, Execute Sub-workflow placeholders for all agents and generation steps, progress callback nodes between agents, quality gate after Strategic Insight, parallel fork for Copywriter/Art Director, and a final completion callback. Run `mcp__n8n-mcp__n8n_validate_workflow` to check structure.
  </verify>
  <done>
Master orchestrator workflow exists in n8n with correct webhook trigger, HMAC verification, PipelineState initialization, sequential agent dispatch with parallel Copywriter/Art Director fork, quality gate after Strategic Insight, progress callbacks between each agent, error handling per agent category (critical-stop vs. partial-delivery), generation sub-workflow placeholders, final completion callback, and async video pipeline fork.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes clean
2. AgentStep type and AGENT_STEP_DEFINITIONS constant exist in pipeline.ts
3. CampaignProgress.agentSteps field exists in schema.ts
4. campaigns table has pipelineState JSONB column (migration SQL exists)
5. Callback handler processes agentStep updates and persists pipelineState
6. GenerationProgress component renders v1.1 per-agent timeline with Japanese labels
7. StrategyAccordion component renders collapsed with steel-blue accent
8. strategyToJapanese() maps internal codes to Japanese prose without framework names
9. n8n master orchestrator workflow exists with correct structure
</verification>

<success_criteria>
- The n8n master orchestrator workflow is created and correctly structured
- Next.js types, schema, and callback handler support per-agent progress and pipelineState storage
- Progress UI renders per-agent timeline with Japanese labels and summaries
- Strategy accordion renders between header and tab bar, collapsed by default
- All user-facing text is Japanese, no English framework names exposed
</success_criteria>

<output>
After completion, create `.planning/phases/09-core-agent-pipeline-generation-execution/09-01-SUMMARY.md`
</output>
