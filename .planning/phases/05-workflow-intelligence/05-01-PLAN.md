---
phase: 05-workflow-intelligence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - src/app/api/campaigns/[id]/regenerate/route.ts
  - src/lib/ai/regeneration.ts
  - src/components/campaign/regenerate-dialog.tsx
  - src/components/campaign/copy-tab.tsx
  - src/components/campaign/image-tab.tsx
  - src/app/(dashboard)/campaigns/[id]/campaign-detail-content.tsx
autonomous: true

must_haves:
  truths:
    - "User can regenerate a single copy variant (e.g., A-case for Instagram) without regenerating entire kit"
    - "User can regenerate a single base image without affecting other images"
    - "Regenerating a base image cascades to re-compositing and re-resizing downstream assets"
    - "New approval/QA/history schema tables exist and are ready for use by other plans"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "Extended campaigns table (parentCampaignId, templateId, approvalStatus) + approvalWorkflows, approvalHistory, qaReports tables"
      contains: "approvalWorkflows"
    - path: "src/app/api/campaigns/[id]/regenerate/route.ts"
      provides: "POST endpoint for selective regeneration by asset type and ID"
      exports: ["POST"]
    - path: "src/lib/ai/regeneration.ts"
      provides: "Per-asset-type regeneration functions (copy variant, image, with cascade)"
      exports: ["regenerateCopyVariant", "regenerateImage"]
    - path: "src/components/campaign/regenerate-dialog.tsx"
      provides: "Regeneration confirmation dialog with asset type selection"
  key_links:
    - from: "src/app/api/campaigns/[id]/regenerate/route.ts"
      to: "src/lib/ai/regeneration.ts"
      via: "import regeneration functions"
      pattern: "import.*from.*regeneration"
    - from: "src/lib/ai/regeneration.ts"
      to: "src/lib/ai/claude.ts"
      via: "dynamic import for copy regeneration"
      pattern: "import.*claude"
    - from: "src/lib/ai/regeneration.ts"
      to: "src/lib/ai/flux.ts"
      via: "dynamic import for image regeneration"
      pattern: "import.*flux"
    - from: "src/components/campaign/copy-tab.tsx"
      to: "/api/campaigns/[id]/regenerate"
      via: "fetch POST on regenerate button click"
      pattern: "fetch.*regenerate"
---

<objective>
Extend database schema for all Phase 5 features and implement selective asset regeneration (WORK-05).

Purpose: This is the foundational plan for Phase 5. The schema extensions support approval workflows, QA reports, campaign history, and template association across all subsequent plans. Selective regeneration transforms the platform from a one-shot generator into an iterative creative tool where users can refine individual assets.

Output: Extended database schema, selective regeneration API endpoint, regeneration helper functions, and UI integration (regenerate buttons on copy variants and images).
</objective>

<execution_context>
@/Users/hani/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-workflow-intelligence/05-RESEARCH.md
@src/lib/db/schema.ts
@src/app/api/campaigns/route.ts
@src/lib/ai/claude.ts
@src/lib/ai/flux.ts
@src/components/campaign/copy-tab.tsx
@src/components/campaign/image-tab.tsx
@src/app/(dashboard)/campaigns/[id]/campaign-detail-content.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend database schema for Phase 5 features and create selective regeneration logic</name>
  <files>
    src/lib/db/schema.ts
    src/lib/ai/regeneration.ts
    src/app/api/campaigns/[id]/regenerate/route.ts
  </files>
  <action>
1. **Extend `src/lib/db/schema.ts`** -- Add the following to the existing schema file:

   a. Add columns to the `campaigns` table definition:
   - `parentCampaignId: uuid("parent_campaign_id").references(() => campaigns.id)` -- self-referencing FK for campaign re-run history
   - `templateId: text("template_id")` -- string ID of the template used (not a FK, templates are static data)
   - `approvalStatus: text("approval_status").default("none")` -- denormalized approval status: 'none' | 'draft' | 'pending_review' | 'pending_approval' | 'approved' | 'rejected' | 'revision_requested'

   b. Add new `approvalWorkflows` table:
   ```
   id: uuid PK defaultRandom
   campaignId: uuid FK -> campaigns.id, notNull, unique (one workflow per campaign)
   status: text notNull default "draft" -- same enum as approvalStatus
   submittedBy: uuid FK -> profiles.id (nullable)
   submittedAt: timestamp with TZ (nullable)
   reviewedBy: uuid FK -> profiles.id (nullable)
   reviewedAt: timestamp with TZ (nullable)
   reviewComment: text (nullable)
   approvedBy: uuid FK -> profiles.id (nullable)
   approvedAt: timestamp with TZ (nullable)
   approvalComment: text (nullable)
   version: integer notNull default 1 -- optimistic locking counter
   createdAt: timestamp with TZ defaultNow
   updatedAt: timestamp with TZ defaultNow
   ```

   c. Add new `approvalHistory` table:
   ```
   id: uuid PK defaultRandom
   workflowId: uuid FK -> approvalWorkflows.id, notNull
   action: text notNull -- 'submitted' | 'reviewed' | 'approved' | 'rejected' | 'revision_requested'
   fromStatus: text notNull
   toStatus: text notNull
   actorId: uuid FK -> profiles.id, notNull
   comment: text (nullable)
   createdAt: timestamp with TZ defaultNow
   ```

   d. Add new `qaReports` table:
   ```
   id: uuid PK defaultRandom
   campaignId: uuid FK -> campaigns.id, notNull
   overallScore: integer notNull -- 0-100
   keigoResult: jsonb notNull -- { passed: boolean, issues: Array<{variantId, field, issue, severity, suggestion}> }
   brandResult: jsonb notNull -- { passed: boolean, issues: Array<{type, description, severity}> }
   createdAt: timestamp with TZ defaultNow
   ```

   Import `integer` from `drizzle-orm/pg-core` if not already imported.

2. **Create `src/lib/ai/regeneration.ts`** -- Per-asset-type regeneration functions. Do NOT add logic inside the existing monolithic `runDirectGeneration`. Create separate, focused functions:

   a. `regenerateCopyVariant(campaignId: string, platform: string, variantLabel: string)`:
   - Fetch the campaign (brief + brandProfile) from DB
   - Dynamic import `generatePlatformCopy` from `@/lib/ai/claude`
   - Call `generatePlatformCopy(brief, brandProfile, [platform])` for the single platform
   - Find the matching variant by index (A-case=0, B-case=1, C-case=2, D-case=3)
   - UPDATE the specific `copyVariants` row matching (campaignId, platform, variantLabel) with new headline, bodyText, ctaText, hashtags, and reset createdAt
   - Return the updated variant

   b. `regenerateImage(campaignId: string, assetId: string)`:
   - Fetch the campaign (brief + brandProfile) and the existing asset from DB
   - Dynamic import `generateCampaignImages` from `@/lib/ai/flux`
   - Generate 1 new image: `await generateCampaignImages(brief, brandProfile, 1)`
   - UPDATE the existing asset row with the new storageKey
   - **Cascade downstream**: Delete all `composited_image` assets whose metadata.baseImageAssetId matches `assetId`, then delete all `platform_image` assets whose metadata.sourceAssetId matches those deleted composited image IDs
   - Re-run compositing for the new image (dynamic import `compositeCampaignImages`), then re-run platform resize for the new composited images
   - Return the updated asset

   c. Helper `getCampaignWithBrand(campaignId: string)`: fetch campaign joined with brand profile, reusable by both functions above.

3. **Create `src/app/api/campaigns/[id]/regenerate/route.ts`** -- POST endpoint:
   - Auth check (same pattern as existing campaign routes: `createClient()`, `getUser()`)
   - Parse body: `{ type: "copy_variant" | "image", assetId?: string, platform?: string, variantLabel?: string }`
   - Validate required fields per type (copy_variant needs platform + variantLabel; image needs assetId)
   - Call appropriate regeneration function
   - Return 200 with the updated asset/variant data
   - Wrap in try/catch, return 500 with error message on failure
  </action>
  <verify>
  Run `pnpm build` -- must compile with no TypeScript errors. Check that:
  - schema.ts exports approvalWorkflows, approvalHistory, qaReports
  - regeneration.ts exports regenerateCopyVariant and regenerateImage
  - regenerate/route.ts exports POST handler
  </verify>
  <done>
  Schema file has 3 new tables (approvalWorkflows, approvalHistory, qaReports) and 3 new columns on campaigns (parentCampaignId, templateId, approvalStatus). Regeneration API accepts POST with type/assetId/platform/variantLabel and calls the appropriate per-asset regeneration function. Image regeneration cascades to downstream composited and platform assets.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add regenerate buttons to copy and image tabs with confirmation dialog</name>
  <files>
    src/components/campaign/regenerate-dialog.tsx
    src/components/campaign/copy-tab.tsx
    src/components/campaign/image-tab.tsx
    src/app/(dashboard)/campaigns/[id]/campaign-detail-content.tsx
  </files>
  <action>
1. **Create `src/components/campaign/regenerate-dialog.tsx`** -- A reusable confirmation dialog component:
   - Props: `open: boolean`, `onOpenChange: (open: boolean) => void`, `title: string`, `description: string`, `onConfirm: () => void`, `isLoading: boolean`
   - Use a simple modal overlay pattern (fixed inset-0 bg-black/50 backdrop, centered white card)
   - Title: bold text, Description: muted text explaining what will be regenerated
   - Two buttons: cancel (outline) and confirm (vermillion bg, shows spinner when loading)
   - Japanese button labels: "キャンセル" and "再生成する"
   - Warn about cascading effects for images: "この画像を再生成すると、合成画像とリサイズ画像も更新されます"

2. **Modify `src/components/campaign/copy-tab.tsx`** -- Add a small regenerate icon button next to each copy variant card:
   - Add a `RefreshCw` icon button (lucide-react) positioned at top-right of each variant card
   - On click: open the regenerate dialog with confirmation text showing the platform + variant label
   - On confirm: POST to `/api/campaigns/${campaignId}/regenerate` with `{ type: "copy_variant", platform, variantLabel }`
   - On success: update the local state with the returned variant data (or trigger page refresh via `router.refresh()`)
   - On error: show toast notification via sonner
   - Add `useState` for dialog open/close state and loading state

3. **Modify `src/components/campaign/image-tab.tsx`** -- Add regenerate button to each image card:
   - Add a `RefreshCw` icon button overlaid on each image (bottom-right, semi-transparent bg)
   - On click: open regenerate dialog with warning about cascading re-compositing
   - On confirm: POST to `/api/campaigns/${campaignId}/regenerate` with `{ type: "image", assetId }`
   - On success: `router.refresh()` to reload all assets (composited + platform images will have changed)
   - On error: show toast via sonner

4. **Modify `src/app/(dashboard)/campaigns/[id]/campaign-detail-content.tsx`** -- Pass campaignId to CopyTab and ImageTab if not already passed:
   - CopyTab already receives `campaignId` -- verify it's used
   - ImageTab needs `campaignId` prop added if not present -- add it to the interface and pass from parent
  </action>
  <verify>
  Run `pnpm build` -- must compile with no TypeScript errors. Verify:
  - regenerate-dialog.tsx renders a modal with title, description, cancel and confirm buttons
  - copy-tab.tsx has RefreshCw import and regenerate fetch call
  - image-tab.tsx has RefreshCw import and regenerate fetch call
  - No import errors or unused variable warnings
  </verify>
  <done>
  Copy tab shows a regenerate button on each variant card. Image tab shows a regenerate button on each image. Clicking either opens a confirmation dialog. Confirming triggers a POST to the regeneration API. Success refreshes the page to show updated assets. Image regeneration dialog warns about downstream cascading.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` passes with zero errors
2. Schema file contains all new tables and columns
3. Regeneration API endpoint is reachable at `/api/campaigns/[id]/regenerate`
4. Regeneration functions handle both copy and image types with proper cascade
5. UI shows regenerate buttons on copy variants and images
</verification>

<success_criteria>
- User can click a regenerate button on any copy variant to regenerate just that variant
- User can click a regenerate button on any image to regenerate just that image with downstream cascade
- Database schema includes all tables needed for Phase 5 plans 02 and 03 (approvalWorkflows, approvalHistory, qaReports, campaign columns)
- Build compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/05-workflow-intelligence/05-01-SUMMARY.md`
</output>
