---
phase: 06-billing-compliance
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/app/api/webhooks/stripe/route.ts
  - src/lib/stripe/sync.ts
  - src/app/api/billing/checkout/route.ts
  - src/app/api/billing/portal/route.ts
  - src/app/api/billing/credits/route.ts
  - src/app/api/billing/estimate/route.ts
autonomous: true

must_haves:
  truths:
    - "Stripe webhook receives events and syncs subscription state to database"
    - "User can create a Checkout session to subscribe to a tier"
    - "User can access Stripe Customer Portal to manage subscription"
    - "API returns credit balance and usage history for a team"
    - "API returns credit cost estimation for a campaign brief"
  artifacts:
    - path: "src/app/api/webhooks/stripe/route.ts"
      provides: "Stripe webhook handler with signature verification"
      exports: ["POST"]
    - path: "src/lib/stripe/sync.ts"
      provides: "Webhook event handlers for subscription lifecycle"
      exports: ["handleCheckoutComplete", "handleSubscriptionChange", "handleInvoicePaid"]
    - path: "src/app/api/billing/checkout/route.ts"
      provides: "Checkout session creation"
      exports: ["POST"]
    - path: "src/app/api/billing/portal/route.ts"
      provides: "Customer portal session"
      exports: ["POST"]
    - path: "src/app/api/billing/credits/route.ts"
      provides: "Credit balance and history API"
      exports: ["GET"]
    - path: "src/app/api/billing/estimate/route.ts"
      provides: "Cost estimation API"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "src/lib/stripe/sync.ts"
      via: "event dispatch to handler functions"
      pattern: "handleCheckoutComplete|handleSubscriptionChange|handleInvoicePaid"
    - from: "src/lib/stripe/sync.ts"
      to: "src/lib/billing/credits.ts"
      via: "grantCredits on invoice payment"
      pattern: "grantCredits"
    - from: "src/app/api/billing/checkout/route.ts"
      to: "src/lib/stripe/client.ts"
      via: "stripe.checkout.sessions.create"
      pattern: "stripe\\.checkout\\.sessions\\.create"
---

<objective>
Create all Stripe-related API routes: webhook handler with signature verification and event dispatch, checkout session creation, customer portal session, and billing data endpoints (credit balance/history, cost estimation).

Purpose: These routes enable the full subscription lifecycle -- user subscribes via Checkout, Stripe events sync state via webhooks, and the app can query billing data.
Output: 6 new API route files providing complete Stripe integration endpoints.
</objective>

<execution_context>
@/Users/hani/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-billing-compliance/06-RESEARCH.md
@.planning/phases/06-billing-compliance/06-01-SUMMARY.md
@src/lib/supabase/server.ts
@src/app/api/campaigns/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Stripe webhook handler and sync logic</name>
  <files>
    src/app/api/webhooks/stripe/route.ts
    src/lib/stripe/sync.ts
  </files>
  <action>
**src/app/api/webhooks/stripe/route.ts** -- Webhook endpoint:
- Import Stripe from "stripe", stripe singleton from @/lib/stripe/client, sync handlers from @/lib/stripe/sync
- Export POST handler:
  1. Read raw body via `request.text()` (NOT request.json() -- Stripe signature requires raw body)
  2. Get `stripe-signature` header
  3. Verify signature with `stripe.webhooks.constructEvent(rawBody, signature, process.env.STRIPE_WEBHOOK_SECRET!)`
  4. Catch verification errors -> return 400
  5. Switch on `event.type`:
     - `checkout.session.completed` -> `handleCheckoutComplete(event.data.object as Stripe.Checkout.Session)`
     - `customer.subscription.updated` -> `handleSubscriptionChange(event.data.object as Stripe.Subscription)`
     - `customer.subscription.deleted` -> `handleSubscriptionChange(event.data.object as Stripe.Subscription)`
     - `invoice.payment_succeeded` -> `handleInvoicePaid(event.data.object as Stripe.Invoice)`
  6. Return `{ received: true }` with 200
- Do NOT use `request.json()` anywhere in this handler

**src/lib/stripe/sync.ts** -- Event handlers:
- Import db, schema tables (stripeCustomers, subscriptions, teams, profiles), drizzle operators
- Import { grantCredits } from @/lib/billing/credits
- Import { getTierIdByPriceId } from @/lib/stripe/config
- Import { getTierById } from @/lib/billing/tiers

`handleCheckoutComplete(session: Stripe.Checkout.Session)`:
1. Extract `session.customer` (string), `session.subscription` (string), `session.metadata.supabaseUserId`
2. If no supabaseUserId, log warning and return
3. Upsert stripeCustomers row: insert { userId: supabaseUserId, stripeCustomerId: session.customer } ON CONFLICT do nothing
4. Fetch the full subscription from Stripe: `stripe.subscriptions.retrieve(session.subscription)`
5. Look up user's team from teamMembers table
6. Determine tier from subscription.items.data[0].price.id using getTierIdByPriceId
7. Upsert subscriptions row with all fields (teamId, stripeSubscriptionId, stripePriceId, tier, status, currentPeriodStart/End)
8. Grant initial credits: call grantCredits(teamId, tierConfig.monthlyCredits, "Initial subscription credits", null)

`handleSubscriptionChange(subscription: Stripe.Subscription)`:
1. Find existing subscription in DB by stripeSubscriptionId
2. If not found, log warning and return
3. Determine new tier from subscription.items.data[0].price.id
4. Update subscription row: tier, status, stripePriceId, currentPeriodStart, currentPeriodEnd, cancelAtPeriodEnd, updatedAt
5. Convert Stripe Unix timestamps to JS Date: `new Date(subscription.current_period_start * 1000)`

`handleInvoicePaid(invoice: Stripe.Invoice)`:
1. Extract subscription ID from invoice.subscription
2. If no subscription (one-off invoice), return
3. Find subscription in DB by stripeSubscriptionId
4. Get tier config to determine credit grant amount
5. Call grantCredits(teamId, tierConfig.monthlyCredits, "Monthly credit renewal", invoice.id)
6. Update subscription currentPeriodStart/End from invoice.lines.data[0].period
  </action>
  <verify>Run `npx tsc --noEmit` to confirm both files compile. Verify webhook handler uses request.text() not request.json().</verify>
  <done>Webhook handler verifies Stripe signatures and dispatches to sync handlers. Sync handlers upsert subscriptions and grant credits on payment.</done>
</task>

<task type="auto">
  <name>Task 2: Create billing API routes (checkout, portal, credits, estimate)</name>
  <files>
    src/app/api/billing/checkout/route.ts
    src/app/api/billing/portal/route.ts
    src/app/api/billing/credits/route.ts
    src/app/api/billing/estimate/route.ts
  </files>
  <action>
All routes follow the existing pattern: createClient() for auth, verify user, find team membership, then business logic. Reference src/app/api/campaigns/route.ts for the auth + team lookup pattern.

**src/app/api/billing/checkout/route.ts** -- POST: Create Checkout session:
1. Auth check (createClient, getUser)
2. Parse body: `{ priceId: string }`
3. Look up or create Stripe customer:
   - Query stripeCustomers by userId
   - If not found: `stripe.customers.create({ email: user.email, metadata: { supabaseUserId: user.id } })`, insert into stripeCustomers
4. Create checkout session:
   ```
   stripe.checkout.sessions.create({
     customer: customerId,
     payment_method_types: ["card"],
     line_items: [{ price: priceId, quantity: 1 }],
     mode: "subscription",
     success_url: `${APP_URL}/billing?success=true&session_id={CHECKOUT_SESSION_ID}`,
     cancel_url: `${APP_URL}/billing?canceled=true`,
     metadata: { supabaseUserId: user.id },
   })
   ```
5. Return `{ url: session.url }` -- client redirects to this URL
- Note: Do NOT set `currency: "jpy"` on checkout session -- currency is set on the Price object in Stripe Dashboard. JPY is zero-decimal: amount 5000 = 5000 yen.

**src/app/api/billing/portal/route.ts** -- POST: Create Customer Portal session:
1. Auth check
2. Look up stripeCustomers by userId
3. If no Stripe customer, return 400 with "サブスクリプションが見つかりません"
4. Create portal session: `stripe.billingPortal.sessions.create({ customer: stripeCustomerId, return_url: `${APP_URL}/billing` })`
5. Return `{ url: session.url }`

**src/app/api/billing/credits/route.ts** -- GET: Credit balance and history:
1. Auth check, find team membership
2. Import { checkBalance, getCreditHistory } from @/lib/billing/credits
3. Fetch balance and history in parallel
4. Return `{ balance: number, history: CreditLedgerEntry[] }`

**src/app/api/billing/estimate/route.ts** -- POST: Estimate campaign cost:
1. Auth check
2. Parse body: `{ platforms: string[], includeVideo?: boolean, includeVoiceover?: boolean, includeAvatar?: boolean }`
3. Import { estimateCampaignCost } from @/lib/billing/estimate
4. Import { checkBalance } from @/lib/billing/credits (to return current balance alongside estimate)
5. Find team, get balance
6. Return `{ estimate: CreditEstimate, currentBalance: number, canAfford: balance >= estimate.totalCredits }`
  </action>
  <verify>Run `npx tsc --noEmit` to confirm all 4 routes compile. Verify each route has proper auth checks.</verify>
  <done>All 4 billing API routes exist. Checkout creates Stripe session with JPY pricing. Portal redirects to Stripe management. Credits returns balance + history. Estimate returns cost breakdown with affordability check.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- All 6 new files exist under src/app/api/ and src/lib/stripe/
- Webhook handler uses request.text() for raw body (not request.json())
- All API routes have authentication checks
- Checkout route references STRIPE_PRICE_IDS from config
- Sync handlers call grantCredits from billing/credits module
</verification>

<success_criteria>
- Stripe webhook receives and verifies events, dispatches to sync handlers
- Checkout session creates subscription with correct JPY pricing
- Customer portal session enables self-service subscription management
- Credits endpoint returns balance and transaction history
- Estimate endpoint returns per-component credit breakdown with affordability flag
</success_criteria>

<output>
After completion, create `.planning/phases/06-billing-compliance/06-02-SUMMARY.md`
</output>
