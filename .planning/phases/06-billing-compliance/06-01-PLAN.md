---
phase: 06-billing-compliance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - src/lib/stripe/client.ts
  - src/lib/stripe/config.ts
  - src/lib/billing/tiers.ts
  - src/lib/billing/credits.ts
  - src/lib/billing/estimate.ts
autonomous: true
user_setup:
  - service: stripe
    why: "Payment processing for subscriptions"
    env_vars:
      - name: STRIPE_SECRET_KEY
        source: "Stripe Dashboard -> Developers -> API keys -> Secret key"
      - name: NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY
        source: "Stripe Dashboard -> Developers -> API keys -> Publishable key"
      - name: STRIPE_WEBHOOK_SECRET
        source: "Stripe CLI: stripe listen --forward-to localhost:3000/api/webhooks/stripe (prints webhook signing secret)"
      - name: STRIPE_STARTER_PRICE_ID
        source: "Stripe Dashboard -> Products -> Create 'Starter' product with 5000 JPY/month recurring price -> copy Price ID (price_...)"
      - name: STRIPE_PRO_PRICE_ID
        source: "Stripe Dashboard -> Products -> Create 'Pro' product with 15000 JPY/month recurring price -> copy Price ID"
      - name: STRIPE_BUSINESS_PRICE_ID
        source: "Stripe Dashboard -> Products -> Create 'Business' product with 50000 JPY/month recurring price -> copy Price ID"
    dashboard_config:
      - task: "Create 3 subscription products (Starter/Pro/Business) with JPY monthly recurring prices"
        location: "Stripe Dashboard -> Products -> Add product"
      - task: "Enable Customer Portal (Settings -> Billing -> Customer portal) with subscription cancellation and plan switching"
        location: "Stripe Dashboard -> Settings -> Billing -> Customer portal"

must_haves:
  truths:
    - "Billing schema tables exist in the database (stripe_customers, subscriptions, credit_ledger, compliance_reports)"
    - "Teams table has a creditBalance column for atomic credit operations"
    - "Tier configuration defines Starter/Pro/Business with JPY pricing and credit allocations"
    - "Credit operations (check, deduct, grant, history) work atomically"
    - "Cost estimation calculates credits from campaign brief parameters"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "Billing schema tables and creditBalance on teams"
      contains: "stripeCustomers"
    - path: "src/lib/stripe/client.ts"
      provides: "Stripe server singleton"
      exports: ["stripe"]
    - path: "src/lib/stripe/config.ts"
      provides: "Stripe price ID mapping"
      exports: ["STRIPE_PRICE_IDS"]
    - path: "src/lib/billing/tiers.ts"
      provides: "Tier definitions with features and credits"
      exports: ["TIERS", "getTierByPriceId"]
    - path: "src/lib/billing/credits.ts"
      provides: "Credit ledger operations"
      exports: ["deductCredits", "grantCredits", "getCreditBalance", "getCreditHistory"]
    - path: "src/lib/billing/estimate.ts"
      provides: "Campaign cost estimation"
      exports: ["estimateCampaignCost"]
  key_links:
    - from: "src/lib/billing/credits.ts"
      to: "src/lib/db/schema.ts"
      via: "teams.creditBalance atomic update"
      pattern: "credit_balance.*>=.*amount"
    - from: "src/lib/billing/tiers.ts"
      to: "src/lib/stripe/config.ts"
      via: "price ID to tier lookup"
      pattern: "STRIPE_PRICE_IDS"
---

<objective>
Create the billing foundation: database schema extensions for Stripe subscriptions, credit ledger, and compliance reports; Stripe client singleton and configuration; tier definitions; credit ledger operations with atomic deduction; and campaign cost estimation logic.

Purpose: All other billing plans depend on these schema tables, types, and utility functions. This is the shared foundation layer.
Output: 6 new/modified files providing the complete billing data layer and business logic.
</objective>

<execution_context>
@/Users/hani/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-billing-compliance/06-RESEARCH.md
@src/lib/db/schema.ts
@src/lib/db/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend database schema with billing tables and creditBalance</name>
  <files>src/lib/db/schema.ts</files>
  <action>
Extend the existing schema.ts file with the following additions:

1. Add `creditBalance` column to the existing `teams` table:
   - `creditBalance: integer("credit_balance").notNull().default(0)`
   - This requires modifying the existing teams table definition to include the new column.

2. Add `stripeCustomers` table:
   - `id: uuid PK defaultRandom()`
   - `userId: uuid FK -> profiles.id, notNull, unique` (one Stripe customer per user)
   - `stripeCustomerId: text, notNull, unique`
   - `createdAt: timestamp with timezone, defaultNow()`

3. Add `subscriptions` table:
   - `id: uuid PK defaultRandom()`
   - `teamId: uuid FK -> teams.id, notNull, unique` (one active subscription per team)
   - `stripeSubscriptionId: text, notNull, unique`
   - `stripePriceId: text, notNull`
   - `tier: text, notNull, default("free")` -- values: 'free' | 'starter' | 'pro' | 'business'
   - `status: text, notNull, default("active")` -- values: 'trialing' | 'active' | 'canceled' | 'past_due' | 'incomplete'
   - `currentPeriodStart: timestamp with timezone`
   - `currentPeriodEnd: timestamp with timezone`
   - `cancelAtPeriodEnd: boolean, default(false)`
   - `createdAt: timestamp with timezone, defaultNow()`
   - `updatedAt: timestamp with timezone, defaultNow()`

4. Add `creditLedger` table:
   - `id: uuid PK defaultRandom()`
   - `teamId: uuid FK -> teams.id, notNull`
   - `amount: integer, notNull` (positive = grant, negative = deduction)
   - `balanceAfter: integer, notNull`
   - `type: text, notNull` -- values: 'grant' | 'deduction' | 'adjustment' | 'expiry'
   - `campaignId: uuid FK -> campaigns.id` (nullable -- only for deductions)
   - `description: text, notNull`
   - `stripeInvoiceId: text` (nullable -- only for grants tied to payments)
   - `createdAt: timestamp with timezone, defaultNow()`

5. Add `complianceReports` table:
   - `id: uuid PK defaultRandom()`
   - `campaignId: uuid FK -> campaigns.id, notNull`
   - `overallRisk: text, notNull` -- values: 'low' | 'medium' | 'high'
   - `keihyouhouResult: jsonb, notNull` (array of compliance issues)
   - `yakkihoResult: jsonb, notNull` (array of compliance issues)
   - `platformRuleResult: jsonb, notNull` (array of platform rule issues)
   - `acknowledgedAt: timestamp with timezone` (nullable)
   - `acknowledgedBy: uuid FK -> profiles.id` (nullable)
   - `createdAt: timestamp with timezone, defaultNow()`

Also add a TypeScript interface for ComplianceIssue:
```typescript
export interface ComplianceIssue {
  category: string
  field: string
  problematicText: string
  issue: string
  severity: "error" | "warning"
  suggestion: string
  legalBasis: string
}
```

Import `boolean` from drizzle-orm/pg-core if not already imported (it is already imported, confirmed from reading schema.ts).

Note: After adding these schema changes, run `npx drizzle-kit push` to sync with the database. If the push fails because the database is not configured, that is acceptable -- the schema definitions are the deliverable here.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no TypeScript errors. Verify the new table exports are importable by checking the file compiles.</verify>
  <done>schema.ts exports stripeCustomers, subscriptions, creditLedger, complianceReports tables and ComplianceIssue interface. teams table includes creditBalance column.</done>
</task>

<task type="auto">
  <name>Task 2: Create Stripe client, config, tier definitions, credit operations, and cost estimation</name>
  <files>
    src/lib/stripe/client.ts
    src/lib/stripe/config.ts
    src/lib/billing/tiers.ts
    src/lib/billing/credits.ts
    src/lib/billing/estimate.ts
  </files>
  <action>
Create 5 new files:

**src/lib/stripe/client.ts** -- Stripe server singleton:
- Import Stripe from "stripe"
- Check process.env.STRIPE_SECRET_KEY exists, throw descriptive error if not
- Export `stripe` as new Stripe instance with `{ typescript: true }`

**src/lib/stripe/config.ts** -- Price ID mapping:
- Export `STRIPE_PRICE_IDS` object mapping tier IDs to env vars:
  ```typescript
  export const STRIPE_PRICE_IDS = {
    starter: process.env.STRIPE_STARTER_PRICE_ID!,
    pro: process.env.STRIPE_PRO_PRICE_ID!,
    business: process.env.STRIPE_BUSINESS_PRICE_ID!,
  } as const
  ```
- Export `getTierIdByPriceId(priceId: string): string | undefined` that reverse-looks up tier from price ID
- Export `APP_URL` = `process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000"`

**src/lib/billing/tiers.ts** -- Tier configuration:
- Define `TierConfig` interface with: id, nameJa, nameEn, monthlyPriceJpy, monthlyCredits, maxBrands, maxTeamMembers, features array
- Export `TIERS` array with 4 tiers:
  - free: 0 JPY, 10 credits/month, 1 brand, 1 member, ["copy_generation", "image_generation"]
  - starter: 5000 JPY, 100 credits, 3 brands, 2 members, adds basic_qa
  - pro: 15000 JPY, 500 credits, 10 brands, 5 members, adds video, qa, compliance, approval
  - business: 50000 JPY, 2000 credits, unlimited (-1), unlimited, adds avatar, priority_support
- Export `getTierById(id: string): TierConfig | undefined`
- Export `getTierByPriceId(priceId: string): TierConfig | undefined` using config.ts mapping
- Export `formatJPY(amount: number): string` using `Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" })`

**src/lib/billing/credits.ts** -- Credit ledger operations:
- Import db, schema tables, eq, sql from drizzle-orm
- `checkBalance(teamId: string): Promise<number>` -- SELECT credit_balance FROM teams
- `deductCredits(teamId, amount, campaignId, description): Promise<{ success: boolean, remainingBalance: number }>` -- Atomic UPDATE WHERE credit_balance >= amount, then INSERT creditLedger entry with negative amount
- `grantCredits(teamId, amount, description, stripeInvoiceId?): Promise<{ newBalance: number }>` -- UPDATE teams credit_balance + amount, INSERT creditLedger with positive amount
- `getCreditHistory(teamId, limit = 50): Promise<CreditLedgerEntry[]>` -- SELECT from creditLedger ordered by createdAt DESC

**src/lib/billing/estimate.ts** -- Cost estimation:
- Define `CreditEstimate` interface: copyCredits, imageCredits, videoCredits, voiceoverCredits, avatarCredits, totalCredits
- `estimateCampaignCost(brief: { platforms: string[], includeVideo?: boolean, includeVoiceover?: boolean, includeAvatar?: boolean }): CreditEstimate`
  - copyCredits = platformCount * 2
  - imageCredits = 4 * 3 (4 base images x 3 credits)
  - videoCredits = includeVideo ? platformCount * 10 : 0
  - voiceoverCredits = includeVoiceover ? 5 : 0
  - avatarCredits = includeAvatar ? 15 : 0
  - totalCredits = sum of all
- Export the function and interface
  </action>
  <verify>Run `npx tsc --noEmit` to confirm all 5 files compile without errors. Verify imports resolve correctly.</verify>
  <done>All 5 files exist with correct exports. Stripe client creates singleton. Tiers define 4 tiers with JPY pricing. Credit operations use atomic SQL. Cost estimation calculates per-component credits.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- schema.ts exports 4 new tables: stripeCustomers, subscriptions, creditLedger, complianceReports
- teams table definition includes creditBalance column
- All billing module files have correct imports and exports
- `npx drizzle-kit push` syncs schema to database (may require database connection)
</verification>

<success_criteria>
- Schema tables defined for complete billing data model
- Stripe client singleton ready for use by API routes
- Tier config provides lookup by ID and price ID
- Credit operations support atomic deduction preventing negative balances
- Cost estimation produces credit breakdown from campaign brief
</success_criteria>

<output>
After completion, create `.planning/phases/06-billing-compliance/06-01-SUMMARY.md`
</output>
