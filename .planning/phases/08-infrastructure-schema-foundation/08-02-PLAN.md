---
phase: 08-infrastructure-schema-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - src/types/campaign.ts
  - src/types/pipeline.ts
  - src/app/api/campaigns/route.ts
  - src/app/api/webhooks/n8n/route.ts
autonomous: true
requirements:
  - ORCH-03
  - ORCH-10
  - ORCH-11
  - ORCH-12
  - ORCH-13
  - ORCH-15

must_haves:
  truths:
    - "brand_memory and campaign_costs tables exist in Supabase with correct columns and foreign keys"
    - "CampaignProgress type supports milestone-based progress with Japanese labels and elapsed time tracking"
    - "PipelineState type defines structured JSON accumulation for agent outputs with scratchpad pattern"
    - "Webhook payload includes mode, brandMemory, agentConfig, and pipelineVersion fields"
    - "campaign_costs table captures per-agent token usage and per-provider API costs separately"
    - "N8nCallbackPayload type supports agent-level progress updates and partial delivery status"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "brand_memory and campaign_costs table definitions"
      contains: "campaignCosts"
    - path: "src/types/pipeline.ts"
      provides: "PipelineState, PipelineMilestone, StrategicInsightOutput, N8nWebhookPayload types"
      contains: "PipelineState"
    - path: "src/types/campaign.ts"
      provides: "Expanded CampaignProgress with milestones"
      contains: "PipelineMilestone"
    - path: "src/app/api/campaigns/route.ts"
      provides: "Expanded webhook payload with agentConfig and mode"
      contains: "agentConfig"
    - path: "src/app/api/webhooks/n8n/route.ts"
      provides: "Expanded callback handler accepting v1.1 payload shape"
      contains: "pipelineVersion"
  key_links:
    - from: "src/lib/db/schema.ts"
      to: "src/types/pipeline.ts"
      via: "Type imports for JSONB column typing"
      pattern: "\\$type<"
    - from: "src/app/api/campaigns/route.ts"
      to: "src/types/pipeline.ts"
      via: "N8nWebhookPayload type for webhook body construction"
      pattern: "N8nWebhookPayload"
    - from: "src/app/api/webhooks/n8n/route.ts"
      to: "src/types/pipeline.ts"
      via: "N8nCallbackPayload type for callback parsing"
      pattern: "N8nCallbackPayload"
    - from: "src/types/campaign.ts"
      to: "src/types/pipeline.ts"
      via: "PipelineMilestone import for CampaignProgress"
      pattern: "PipelineMilestone"
---

<objective>
Add brand_memory and campaign_costs tables to the Drizzle schema, expand the CampaignProgress type with milestone-based tracking, define the PipelineState type for agent scratchpad pattern, and update webhook payload and callback handler to accept the v1.1 shape.

Purpose: These schema additions and type definitions are the data layer foundation for the entire 7-agent pipeline built in Phases 9-12. Without them, agents have nowhere to log costs, accumulate outputs, or report progress.

Output: Two new database tables applied to Supabase, expanded TypeScript types for pipeline orchestration, updated webhook payload and callback handler.
</objective>

<execution_context>
@/Users/hani/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-infrastructure-schema-foundation/08-RESEARCH.md
@.planning/phases/08-infrastructure-schema-foundation/08-CONTEXT.md
@src/lib/db/schema.ts
@src/types/campaign.ts
@src/app/api/campaigns/route.ts
@src/app/api/webhooks/n8n/route.ts
@src/hooks/use-campaign-progress.ts
@drizzle.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add database tables and pipeline types</name>
  <files>src/lib/db/schema.ts, src/types/pipeline.ts, src/types/campaign.ts</files>
  <action>
**1. Create `src/types/pipeline.ts`** with all v1.1 pipeline type definitions:

```typescript
/**
 * v1.1 Pipeline types for 7-agent orchestration.
 *
 * These types define the data contracts between:
 * - Next.js app and n8n (webhook payload)
 * - n8n agents (PipelineState accumulation)
 * - n8n and Next.js (callback payload)
 * - Dashboard UI (milestone progress)
 */

import type { BrandColors, ProductCatalogEntry } from "@/lib/db/schema"

// ===== Pipeline Milestones (Progress Display) =====

/**
 * Milestone-based progress for the v1.1 pipeline.
 * User decision: 3-4 high-level milestones, Japanese labels, no agent internals exposed.
 */
export interface PipelineMilestone {
  id: "strategy" | "content" | "assets" | "packaging"
  label: string        // Japanese label shown to user
  status: "pending" | "active" | "complete" | "failed"
  startedAt?: string   // ISO timestamp -- used for elapsed time counter
  completedAt?: string // ISO timestamp
  error?: string       // Friendly Japanese error message (only for critical-stop failures)
}

/**
 * Milestone definitions with agent-to-milestone mapping.
 * Claude's discretion: mapping agents to the 4 user-decided milestones.
 */
export const PIPELINE_MILESTONES: readonly {
  id: PipelineMilestone["id"]
  label: string
  agents: string[]
  criticalStop: boolean
}[] = [
  {
    id: "strategy",
    label: "戦略分析中",
    agents: ["strategic_insight"],
    criticalStop: true,  // Strategic Insight failure stops pipeline
  },
  {
    id: "content",
    label: "コンテンツ作成中",
    agents: ["creative_director", "copywriter", "jp_localization"],
    criticalStop: false, // Creative Director is critical-stop within this milestone, but Copywriter/JP Localization are partial-delivery
  },
  {
    id: "assets",
    label: "アセット生成中",
    agents: ["art_director"],
    criticalStop: false, // Art Director is partial-delivery
  },
  {
    id: "packaging",
    label: "パッケージング",
    agents: [],
    criticalStop: false, // Compositing, resize, ZIP -- all partial-delivery
  },
] as const

/**
 * Friendly Japanese error messages for critical-stop failures.
 * User decision: only 2 messages needed (Strategic Insight + Creative Director).
 */
export const CRITICAL_STOP_ERRORS = {
  strategic_insight:
    "戦略分析を完了できませんでした。お手数ですが、もう一度お試しください。",
  creative_director:
    "クリエイティブの方向性を生成できませんでした。お手数ですが、もう一度お試しください。",
} as const

// ===== PipelineState (Agent Scratchpad) =====

/**
 * Structured JSON object that accumulates each agent's output through the pipeline.
 * ORCH-03: Accumulates agent outputs. ORCH-13: Only structured JSON summaries, not full reasoning.
 *
 * Each agent writes to its designated section. Downstream agents read upstream sections.
 * The scratchpad pattern means agents pass structured summaries, not full reasoning chains.
 */
export interface PipelineState {
  version: "v1.1"
  campaignId: string
  mode: "auto" | "pro"
  status: "running" | "complete" | "partial" | "failed"

  // Agent output sections (populated as pipeline progresses)
  strategicInsight?: StrategicInsightOutput
  creativeDirector?: CreativeDirectorOutput
  copywriter?: CopywriterOutput
  artDirector?: ArtDirectorOutput
  jpLocalization?: JpLocalizationOutput

  // Error tracking for partial delivery (ORCH-12)
  agentErrors: AgentError[]

  // Metadata
  startedAt: string
  completedAt?: string
}

/**
 * Strategic Insight agent output.
 * Quality gate: must pass schema validation with minimum required fields before pipeline continues.
 */
export interface StrategicInsightOutput {
  awarenessLevel: string          // Schwartz awareness classification
  lf8Desires: string[]            // At least one LF8 desire identified
  copywritingFramework: string    // PAS | AIDA | BAB | SB7
  targetInsight: string           // Substantive audience insight (min 10 chars)
  creativeDirection: string       // Direction for Creative Director (min 10 chars)
  keyMessages: string[]           // Core messages to convey
  tonalGuidance: string           // Register and tone recommendation
}

export interface CreativeDirectorOutput {
  visualConcept: string           // Overall visual direction
  colorGuidance: string           // Color palette recommendation
  compositionNotes: string        // Layout and composition direction
  moodKeywords: string[]          // Visual mood keywords
  platformAdaptations: Record<string, string>  // Per-platform visual notes
}

export interface CopywriterOutput {
  variants: {
    platform: string
    variantLabel: string
    headline: string
    body: string
    cta: string
    hashtags: string[]
    register: string
  }[]
}

export interface ArtDirectorOutput {
  imagePrompts: {
    platform: string
    prompt: string
    negativePrompt?: string
    style: string
    aspectRatio: string
  }[]
}

export interface JpLocalizationOutput {
  approved: boolean
  revisionsApplied: number        // 0 = first pass approved, 1-2 = revisions needed
  localizationNotes: string       // What was adjusted and why
  qualityScore: number            // 0-100
}

export interface AgentError {
  agentName: string
  timestamp: string
  message: string
  retryAttempted: boolean         // ORCH-10: 1 silent auto-retry
  retrySucceeded?: boolean
  isCriticalStop: boolean         // Strategic Insight or Creative Director
}

// ===== Webhook Payload (Next.js -> n8n) =====

/**
 * Expanded webhook payload sent from Next.js to n8n when triggering a campaign.
 * v1.0 fields preserved for backward compatibility. v1.1 fields added.
 */
export interface N8nWebhookPayload {
  // v1.0 fields (preserved)
  campaignId: string
  brief: {
    brandProfileId: string
    objective: string
    targetAudience: string
    platforms: string[]
    registerOverride?: string
    creativeMoodTags: string[]
    creativeDirection: string
    referenceImageUrl?: string
    campaignProductInfo?: string
  }
  brandProfile: {
    id: string
    name: string
    colors: BrandColors | null
    fontPreference: string | null
    defaultRegister: string
    toneTags: string[] | null
    toneDescription: string | null
    productCatalog: ProductCatalogEntry[] | null
    positioningStatement: string | null
    brandStory: string | null
    targetMarket: string | null
    brandValues: string[] | null
  }

  // v1.1 fields (new)
  mode: "auto" | "pro"
  brandMemory: BrandVoiceSummary | null   // null until Phase 11 populates
  agentConfig: {
    strategicInsight: { model: string }
    creativeDirector: { model: string }
    copywriter: { model: string }
    artDirector: { model: string }
    jpLocalization: { model: string }
  }
  pipelineVersion: "v1.0" | "v1.1"
}

// ===== Callback Payload (n8n -> Next.js) =====

/**
 * Expanded callback payload sent from n8n back to Next.js.
 * Supports both v1.0 stage-based updates and v1.1 milestone-based updates.
 */
export interface N8nCallbackPayload {
  campaignId: string
  status: "success" | "failure" | "progress" | "partial"
  pipelineVersion?: "v1.0" | "v1.1"

  // v1.0 fields (preserved for backward compat)
  copyVariants?: {
    platform: string
    variantLabel: string
    register: string
    headline: string
    body: string
    cta: string
    hashtags: string[]
  }[]
  imageUrls?: string[]
  videoAssets?: {
    url: string
    provider: string
    aspectRatio: string
    duration: number
    type: string
    mimeType: string
  }[]
  audioAssets?: {
    url: string
    provider: string
    duration: number
    mimeType: string
    voiceId: string
  }[]
  stage?: string
  error?: string

  // v1.1 fields (new)
  milestone?: PipelineMilestone         // Current milestone update
  pipelineState?: PipelineState         // Full pipeline state on completion
  costEntries?: CostEntry[]             // Cost entries to persist
  agentError?: AgentError               // Agent-specific error
}

/**
 * Cost entry for persisting to campaign_costs table.
 * Sent from n8n after each agent call or provider call.
 */
export interface CostEntry {
  entryType: "agent" | "provider"
  // Agent fields
  agentName?: string
  modelUsed?: string
  inputTokens?: number
  outputTokens?: number
  // Provider fields
  providerName?: string
  operationType?: string
  durationMs?: number
  // Shared
  costYen: number
  success: boolean
  errorMessage?: string
  metadata?: Record<string, unknown>
}

// ===== Brand Memory Types =====

export interface BrandMemorySignal {
  source: "favorite" | "approval" | "register_selection" | "campaign_feedback"
  campaignId: string
  signalType: "tone_preference" | "cta_style" | "keigo_level" | "visual_preference"
  value: string
  confidence: number    // 0.0 to 1.0
  extractedAt: string   // ISO timestamp
}

export interface BrandVoiceSummary {
  sentenceLength: "short" | "medium" | "long"
  keigoLevel: "casual" | "standard" | "formal"
  ctaStyle: "direct" | "soft" | "question"
  preferredExpressions: string[]
  avoidExpressions: string[]
  lastUpdated: string   // ISO timestamp
}
```

**2. Update `src/lib/db/schema.ts`** -- add two new tables at the end of the file, before the closing. Import `numeric` and `boolean` (boolean already imported, numeric needs adding). Add the new tables:

Add `numeric` to the import from `drizzle-orm/pg-core` (it's not currently imported).

Add these tables after the `complianceReports` table:

```typescript
// ===== v1.1 Pipeline Tables =====

/**
 * Brand memory -- accumulated voice and style signals per brand profile.
 * Populated in Phase 11, schema created now.
 * Each row = one brand profile's accumulated learning.
 */
export const brandMemory = pgTable("brand_memory", {
  id: uuid("id").primaryKey().defaultRandom(),
  brandProfileId: uuid("brand_profile_id")
    .references(() => brandProfiles.id)
    .notNull(),
  teamId: uuid("team_id")
    .references(() => teams.id)
    .notNull(),
  signals: jsonb("signals").$type<import("@/types/pipeline").BrandMemorySignal[]>().default([]),
  voiceSummary: jsonb("voice_summary").$type<import("@/types/pipeline").BrandVoiceSummary>(),
  schemaVersion: integer("schema_version").notNull().default(1),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
})

/**
 * Per-campaign cost tracking.
 * Each row = one agent call or one provider API call within a campaign.
 * Campaign total = SUM of all rows for that campaign.
 *
 * User decisions:
 * - Per-agent token usage AND per-provider API cost logged separately
 * - Data per agent call: agent name, model used, input tokens, output tokens, cost in yen
 * - Data per provider call: provider name, operation type, cost in yen, duration
 * - Campaign total aggregated from subtotals
 * - Configurable cost alert threshold via CAMPAIGN_COST_ALERT_THRESHOLD_YEN env var
 */
export const campaignCosts = pgTable("campaign_costs", {
  id: uuid("id").primaryKey().defaultRandom(),
  campaignId: uuid("campaign_id")
    .references(() => campaigns.id)
    .notNull(),
  entryType: text("entry_type").notNull(),      // 'agent' | 'provider'
  // Agent-specific fields
  agentName: text("agent_name"),                // 'strategic_insight' | 'creative_director' | 'copywriter' | 'art_director' | 'jp_localization'
  modelUsed: text("model_used"),                // 'claude-opus-4-6' | 'claude-sonnet-4-5'
  inputTokens: integer("input_tokens"),
  outputTokens: integer("output_tokens"),
  // Provider-specific fields
  providerName: text("provider_name"),          // 'flux' | 'kling' | 'runway' | 'elevenlabs' | 'heygen'
  operationType: text("operation_type"),        // 'image_generation' | 'video_generation' | 'voice_synthesis' | 'avatar_generation'
  durationMs: integer("duration_ms"),
  // Cost (shared)
  costYen: numeric("cost_yen", { precision: 10, scale: 4 }),
  // Status
  success: boolean("success").notNull().default(true),
  errorMessage: text("error_message"),
  // Metadata
  metadata: jsonb("metadata"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
})
```

Note: Use `import("@/types/pipeline")` for the JSONB type annotations to avoid circular dependency. This follows the pattern used by existing tables.

**IMPORTANT:** Drizzle `numeric()` returns strings in TypeScript. This is correct behavior -- document this in a comment near the table. Consumers must use `parseFloat()` when reading costYen for comparisons.

**3. Update `src/types/campaign.ts`** -- expand CampaignProgress with milestone support:

Add to the existing CampaignProgress interface (do NOT remove any existing fields -- backward compatibility required):

```typescript
import type { PipelineMilestone } from "@/types/pipeline"

// Add these optional fields to the CampaignProgress interface:
  // v1.1 milestone-based progress (optional -- only present for v1.1 pipeline)
  milestones?: PipelineMilestone[]
  pipelineVersion?: "v1.0" | "v1.1"
```

The existing v1.0 fields (copyStatus, imageStatus, etc.) must remain for backward compatibility with the direct generation fallback path and existing campaigns.

**4. Update `src/lib/db/schema.ts` CampaignProgress interface** -- mirror the same expansion in the schema-level interface (it duplicates the types/campaign.ts interface). Add the same `milestones` and `pipelineVersion` optional fields.

**5. Run Drizzle migration:**
```bash
npx drizzle-kit generate --name add-brand-memory-campaign-costs
npx drizzle-kit push
```

If `drizzle-kit push` fails due to missing DATABASE_URL, this will be handled in Task 2 verification. The schema.ts changes are the primary artifact; migration can be pushed during deployment.
  </action>
  <verify>
- `npx tsc --noEmit` passes with no type errors
- `src/lib/db/schema.ts` contains `brandMemory` and `campaignCosts` table exports
- `src/types/pipeline.ts` exists and exports PipelineState, N8nWebhookPayload, N8nCallbackPayload, CostEntry, PIPELINE_MILESTONES, CRITICAL_STOP_ERRORS
- `src/types/campaign.ts` CampaignProgress has `milestones?: PipelineMilestone[]` and `pipelineVersion?` fields
- `npx drizzle-kit generate --name add-brand-memory-campaign-costs` produces migration SQL (may need DATABASE_URL set)
  </verify>
  <done>brand_memory and campaign_costs tables defined in schema.ts, PipelineState and all supporting types defined in pipeline.ts, CampaignProgress expanded with milestones, migration SQL generated</done>
</task>

<task type="auto">
  <name>Task 2: Expand webhook payload and callback handler for v1.1</name>
  <files>src/app/api/campaigns/route.ts, src/app/api/webhooks/n8n/route.ts</files>
  <action>
**1. Update `src/app/api/campaigns/route.ts`** -- expand the webhook payload in the POST handler:

In the section where `const payload = JSON.stringify({...})` is constructed (around line 204), expand it to include v1.1 fields. The expanded payload should be:

```typescript
import type { N8nWebhookPayload } from "@/types/pipeline"

// Build the payload with v1.1 fields
const webhookPayload: N8nWebhookPayload = {
  campaignId: campaign.id,
  brief,
  brandProfile: {
    id: brandProfile.id,
    name: brandProfile.name,
    colors: brandProfile.colors,
    fontPreference: brandProfile.fontPreference,
    defaultRegister: brandProfile.defaultRegister,
    toneTags: brandProfile.toneTags,
    toneDescription: brandProfile.toneDescription,
    productCatalog: brandProfile.productCatalog,
    positioningStatement: brandProfile.positioningStatement,
    brandStory: brandProfile.brandStory,
    targetMarket: brandProfile.targetMarket,
    brandValues: brandProfile.brandValues,
  },
  // v1.1 expanded fields
  mode: "pro",                    // Default to 'pro' until Auto mode (Phase 10)
  brandMemory: null,              // null until Phase 11 populates
  agentConfig: {
    strategicInsight: { model: process.env.AGENT_STRATEGIC_INSIGHT_MODEL || "claude-opus-4-6" },
    creativeDirector: { model: process.env.AGENT_CREATIVE_DIRECTOR_MODEL || "claude-opus-4-6" },
    copywriter: { model: process.env.AGENT_COPYWRITER_MODEL || "claude-opus-4-6" },
    artDirector: { model: process.env.AGENT_ART_DIRECTOR_MODEL || "claude-opus-4-6" },
    jpLocalization: { model: process.env.AGENT_JP_LOCALIZATION_MODEL || "claude-opus-4-6" },
  },
  pipelineVersion: "v1.1",
}

const payload = JSON.stringify(webhookPayload)
```

Per user decision: all agents default to Opus (claude-opus-4-6) if env var not set.

Also update the initial progress when n8n webhook is triggered to include v1.1 milestone initialization:

```typescript
import { PIPELINE_MILESTONES } from "@/types/pipeline"

// When updating status to "generating" after successful webhook trigger:
progress: {
  stage: "n8n_triggered",
  copyStatus: "generating",
  imageStatus: "generating",
  percentComplete: 10,
  currentStep: "AI生成パイプラインを開始しました",
  // v1.1 milestone initialization
  pipelineVersion: "v1.1",
  milestones: PIPELINE_MILESTONES.map(m => ({
    id: m.id,
    label: m.label,
    status: "pending" as const,
  })),
},
```

**2. Update `src/app/api/webhooks/n8n/route.ts`** -- expand the callback handler to accept v1.1 payloads:

Replace the local `N8nWebhookPayload` interface with an import from pipeline.ts:

```typescript
import type { N8nCallbackPayload, CostEntry } from "@/types/pipeline"
import { campaignCosts } from "@/lib/db/schema"
```

Update the POST handler to handle v1.1-specific callback fields:

After the existing success handling block but before the final campaign status update, add:

```typescript
// Handle v1.1 milestone progress updates
if (payload.milestone) {
  const currentCampaign = await db
    .select({ progress: campaigns.progress })
    .from(campaigns)
    .where(eq(campaigns.id, campaignId))
    .limit(1)

  const existingProgress = (currentCampaign[0]?.progress ?? {}) as CampaignProgress
  const milestones = existingProgress.milestones || []

  // Update the specific milestone
  const updatedMilestones = milestones.map(m =>
    m.id === payload.milestone!.id ? { ...m, ...payload.milestone } : m
  )

  await db
    .update(campaigns)
    .set({
      progress: {
        ...existingProgress,
        milestones: updatedMilestones,
      } as CampaignProgress,
    })
    .where(eq(campaigns.id, campaignId))
}

// Persist cost entries (ORCH-15)
if (payload.costEntries && payload.costEntries.length > 0) {
  for (const entry of payload.costEntries) {
    await db.insert(campaignCosts).values({
      campaignId,
      entryType: entry.entryType,
      agentName: entry.agentName,
      modelUsed: entry.modelUsed,
      inputTokens: entry.inputTokens,
      outputTokens: entry.outputTokens,
      providerName: entry.providerName,
      operationType: entry.operationType,
      durationMs: entry.durationMs,
      costYen: entry.costYen?.toString(),   // Drizzle numeric expects string input
      success: entry.success,
      errorMessage: entry.errorMessage,
      metadata: entry.metadata,
    })
  }

  // Check cost alert threshold
  const COST_ALERT_THRESHOLD_YEN = parseInt(
    process.env.CAMPAIGN_COST_ALERT_THRESHOLD_YEN || "5000",
    10
  )

  const costResult = await db
    .select({
      totalCost: sql<string>`SUM(${campaignCosts.costYen})`,
    })
    .from(campaignCosts)
    .where(eq(campaignCosts.campaignId, campaignId))

  const totalCost = parseFloat(costResult[0]?.totalCost || "0")
  if (totalCost > COST_ALERT_THRESHOLD_YEN) {
    console.warn(
      `[COST ALERT] Campaign ${campaignId} cost ¥${totalCost.toFixed(2)} ` +
      `exceeds threshold ¥${COST_ALERT_THRESHOLD_YEN}`
    )
  }
}
```

Add `sql` to drizzle-orm imports: `import { eq, and, sql } from "drizzle-orm"`

The existing v1.0 callback handling (copyVariants, imageUrls, videoAssets, audioAssets) must remain untouched for backward compatibility. The v1.1 additions are additive.

**3. Preserve backward compatibility:**
- The webhook trigger payload is always v1.1 format now (n8n 2.x handles it)
- The callback handler accepts BOTH v1.0 and v1.1 shapes (checks for `payload.milestone`, `payload.costEntries` optionally)
- The progress JSONB includes BOTH v1.0 status fields and v1.1 milestones (for existing UI compatibility)
  </action>
  <verify>
- `npx tsc --noEmit` passes with no type errors
- `src/app/api/campaigns/route.ts` constructs payload with `agentConfig`, `mode`, `brandMemory`, `pipelineVersion` fields
- `src/app/api/webhooks/n8n/route.ts` handles `payload.milestone` and `payload.costEntries`
- `src/app/api/webhooks/n8n/route.ts` imports from `@/types/pipeline` instead of local interface definitions
- Existing v1.0 callback fields (copyVariants, imageUrls, etc.) still handled
- Cost alert threshold check present with console.warn
  </verify>
  <done>Webhook payload includes v1.1 fields (mode, agentConfig, brandMemory, pipelineVersion), callback handler accepts milestone updates and cost entries, cost alert threshold check fires on exceeding CAMPAIGN_COST_ALERT_THRESHOLD_YEN, all backward compatible with v1.0</done>
</task>

</tasks>

<verification>
- TypeScript compiles without errors: `npx tsc --noEmit`
- brand_memory table has: id, brand_profile_id (FK), team_id (FK), signals (JSONB), voice_summary (JSONB), schema_version, created_at, updated_at
- campaign_costs table has: id, campaign_id (FK), entry_type, agent_name, model_used, input_tokens, output_tokens, provider_name, operation_type, duration_ms, cost_yen (numeric), success, error_message, metadata, created_at
- PipelineState type has version, campaignId, mode, status, agent output sections, agentErrors
- N8nWebhookPayload type has mode, brandMemory, agentConfig, pipelineVersion
- CampaignProgress has milestones array with PipelineMilestone items
- PIPELINE_MILESTONES constant has 4 entries with Japanese labels matching user decision
- CRITICAL_STOP_ERRORS has exactly 2 entries (strategic_insight, creative_director)
- Webhook payload in campaigns/route.ts reads AGENT_*_MODEL env vars with Opus fallback
- Callback handler persists cost entries to campaign_costs table
</verification>

<success_criteria>
Two new database tables (brand_memory, campaign_costs) are defined and migrated. PipelineState, milestone, and webhook types are fully specified. The webhook trigger sends v1.1 payloads and the callback handler accepts v1.1 responses including cost tracking and milestone updates.
</success_criteria>

<output>
After completion, create `.planning/phases/08-infrastructure-schema-foundation/08-02-SUMMARY.md`
</output>
