---
phase: 03-multi-platform-formatting
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - src/app/api/campaigns/route.ts
  - src/lib/platforms/zip-packager.ts
  - src/app/api/campaigns/[id]/download/route.ts
autonomous: true

must_haves:
  truths:
    - "Campaign generation produces platform-specific copy (not duplicated generic copy)"
    - "Campaign generation resizes composited images to all selected platform dimensions and stores them"
    - "Platform-resized assets are stored in Supabase with type 'platform_image' and platform metadata"
    - "ZIP download endpoint streams a campaign kit organized by platform folders"
  artifacts:
    - path: "src/app/api/campaigns/route.ts"
      provides: "Updated runDirectGeneration with platform copy + resize + email pipeline"
      contains: "generatePlatformCopy"
    - path: "src/lib/platforms/zip-packager.ts"
      provides: "ZIP archive builder using archiver with platform folder structure"
      exports: ["buildCampaignZip"]
    - path: "src/app/api/campaigns/[id]/download/route.ts"
      provides: "ZIP download streaming endpoint"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/campaigns/route.ts"
      to: "src/lib/ai/claude.ts"
      via: "import generatePlatformCopy replacing generateCopy"
      pattern: "generatePlatformCopy"
    - from: "src/app/api/campaigns/route.ts"
      to: "src/lib/platforms/image-resizer.ts"
      via: "import resizeForPlatforms for post-compositing resize"
      pattern: "resizeForPlatforms"
    - from: "src/app/api/campaigns/[id]/download/route.ts"
      to: "src/lib/platforms/zip-packager.ts"
      via: "import buildCampaignZip"
      pattern: "buildCampaignZip"
---

<objective>
Wire platform-specific copy generation and image resizing into the campaign generation pipeline, add the ZIP download endpoint for campaign kit delivery.

Purpose: Requirements WORK-02 (end-to-end orchestration), WORK-08 (ZIP download), and all PLAT-* requirements (pipeline produces the platform assets). This is the integration plan that connects Plan 01 and Plan 02 utilities into the live pipeline.
Output: Updated generation pipeline, ZIP packager utility, ZIP download API endpoint.
</objective>

<execution_context>
@/Users/hani/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hani/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-multi-platform-formatting/03-RESEARCH.md

@src/app/api/campaigns/route.ts
@src/app/api/campaigns/[id]/route.ts
@src/lib/db/schema.ts
@src/lib/compositing/index.ts

# Prior plan outputs needed
@.planning/phases/03-multi-platform-formatting/03-01-SUMMARY.md
@.planning/phases/03-multi-platform-formatting/03-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire platform copy + image resize into generation pipeline</name>
  <files>src/app/api/campaigns/route.ts</files>
  <action>
Modify `runDirectGeneration()` in `src/app/api/campaigns/route.ts`:

**Copy generation change:**
1. Replace `generateCopy(brief, brandProfile)` with `generatePlatformCopy(brief, brandProfile, brief.platforms)` (from `@/lib/ai/claude`)
2. Change the copy variant insertion loop:
   - OLD: generates 4 generic variants, then inserts the SAME 4 variants for EACH platform (duplicating)
   - NEW: `generatePlatformCopy` returns `{ platforms: [{ platformId, variants }] }` -- iterate over platforms, insert each platform's specific 4 variants
   - Keep using the existing `copyVariants` table -- it already has a `platform` column
3. Keep the variant labels as "A案", "B案", "C案", "D案"

**Image resize stage (new, after compositing):**
1. Add a new pipeline stage after compositing: "platform_resize"
2. Update progress: `{ stage: "platform_resize", ..., platformResizeStatus: "generating", percentComplete: 85, currentStep: "プラットフォーム別リサイズ中..." }`
3. Gather all composited image assets (type === "composited_image") from the DB for this campaign -- take the first composited image per base image (layout A variant, the best one)
4. For each selected composited image, fetch its buffer from Supabase Storage URL
5. Call `resizeForPlatforms(buffer, width, height, getResizeTargetsForPlatforms(brief.platforms), brandProfile.colors?.background)`
6. Upload each resized buffer to Supabase Storage bucket "platform-images" at path `{campaignId}/{platformId}/{fileName}`
7. Insert asset records with:
   - `type: "platform_image"`
   - `storageKey`: the public URL
   - `width` / `height`: the target dimensions as strings
   - `metadata: { platform: platformId, dimensionLabel: label, sourceAssetId: compositedAssetId }`

**Email HTML generation (if email platform selected):**
1. After copy and image generation, check if `brief.platforms.includes("email")`
2. If yes, call `buildEmailHtml()` from `@/lib/platforms/email-template`
3. Use the first email copy variant (A案) for headline/body/cta
4. Use the email header image (platform_image with platform "email" and label "ヘッダー") for the header image URL
5. Upload the HTML string as a file to Supabase Storage: `{campaignId}/email/email-template.html`
6. Insert asset record with `type: "email_html"`, `mimeType: "text/html"`

**Progress tracking updates:**
- Add `platformResizeStatus` and `emailStatus` to progress object
- Final complete state includes all statuses
- Platform resize failure is non-fatal (same pattern as compositing -- campaign completes with warning)

**Do NOT modify** the n8n webhook path -- only `runDirectGeneration` changes. n8n integration will use the same utilities when configured.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors. Verify `runDirectGeneration` references `generatePlatformCopy`, `resizeForPlatforms`, and `buildEmailHtml`.
  </verify>
  <done>
runDirectGeneration produces platform-specific copy (not duplicated), resizes composited images to all platform dimensions, generates email HTML when email platform is selected. Pipeline stages tracked in progress object.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ZIP packager and download endpoint</name>
  <files>src/lib/platforms/zip-packager.ts, src/app/api/campaigns/[id]/download/route.ts</files>
  <action>
**Install archiver:**
Run `npm install archiver @types/archiver`

**Create `src/lib/platforms/zip-packager.ts`:**

1. **`buildCampaignZip(campaignId: string): Promise<{ stream: PassThrough; fileName: string }>`**
   - Query DB: fetch all assets for campaignId (platform_image, email_html types)
   - Query DB: fetch all copy variants for campaignId
   - Create archiver ZIP instance: `archiver("zip", { zlib: { level: 6 } })`
   - Pipe to a PassThrough stream
   - **Add platform images:** For each platform_image asset, fetch buffer from storageKey URL (use `Promise.all` for parallel fetching, batched in groups of 5 to avoid overwhelming), append to archive at `{platformId}/{fileName}`
   - **Add copy as text files:** For each platform, format all 4 variants into a readable text file:
     ```
     プラットフォーム: {platform Japanese name}

     === A案 ===
     見出し: {headline}
     本文: {bodyText}
     CTA: {ctaText}
     ハッシュタグ: {hashtags.join(" ")}

     === B案 ===
     ...
     ```
     Append as `{platformId}/copy.txt`
   - **Add email HTML:** If email_html asset exists, fetch and add as `email/template.html`
   - **Add composited images:** Add composited_image assets as `composited/{fileName}`
   - Call `archive.finalize()`
   - Return the PassThrough stream and suggested filename `campaign-kit-{campaignId.slice(0,8)}.zip`
   - Import platform name lookup from `@/lib/constants/platforms` for Japanese platform names in copy.txt

2. Handle errors: if a single asset fetch fails, log warning and skip (don't fail the whole ZIP)

**Create `src/app/api/campaigns/[id]/download/route.ts`:**

1. **GET handler** with auth verification (same pattern as existing campaign [id] route)
2. Verify user belongs to team that owns the campaign
3. Call `buildCampaignZip(campaignId)`
4. Convert Node PassThrough stream to Web ReadableStream:
   ```typescript
   const webStream = new ReadableStream({
     start(controller) {
       passthrough.on("data", (chunk: Buffer) => controller.enqueue(new Uint8Array(chunk)))
       passthrough.on("end", () => controller.close())
       passthrough.on("error", (err: Error) => controller.error(err))
     },
   })
   ```
5. Return `new Response(webStream, { headers: { "Content-Type": "application/zip", "Content-Disposition": "attachment; filename=...", "Cache-Control": "no-store" } })`
6. If campaign has no downloadable assets, return 404 with message "ダウンロード可能なアセットがありません"
  </action>
  <verify>
Run `npm install archiver @types/archiver` succeeds. Run `npx tsc --noEmit` -- no type errors. Verify the download route file exists at the correct path.
  </verify>
  <done>
ZIP packager builds a campaign kit archive organized by platform folders with images and copy text files. Download endpoint streams the ZIP with auth verification. Failed individual asset fetches are skipped gracefully.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `runDirectGeneration` calls `generatePlatformCopy` (not `generateCopy`) for copy generation
3. Platform image resize stage exists after compositing in the pipeline
4. Assets of type "platform_image" are inserted with platform metadata
5. ZIP download endpoint exists at `/api/campaigns/[id]/download`
6. `archiver` is in package.json dependencies
</verification>

<success_criteria>
- Campaign generation pipeline produces platform-specific copy variants (different per platform)
- Composited images are resized to all selected platform dimensions and stored
- Email HTML template generated when email platform is selected
- ZIP download endpoint streams campaign kit organized by platform folders
- Pipeline failures in resize/email stages are non-fatal
</success_criteria>

<output>
After completion, create `.planning/phases/03-multi-platform-formatting/03-03-SUMMARY.md`
</output>
